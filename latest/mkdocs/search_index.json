{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl\n\n\n\n\nChainMap.Arguments\n\n\nChainMap.LazyCall\n\n\nBase.merge\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nChainMap.arguments_block\n\n\nChainMap.bitnot\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.collect_arguments\n\n\nChainMap.collect_call\n\n\nChainMap.lambda\n\n\nChainMap.lazy_call\n\n\nChainMap.nonstandard\n\n\nChainMap.push\n\n\nChainMap.push_block\n\n\nChainMap.unshift\n\n\nChainMap.unweave\n\n\nChainMap.unweave\n\n\nChainMap.@arguments_block\n\n\nChainMap.@chain\n\n\nChainMap.@lambda\n\n\nChainMap.@lazy_call\n\n\nChainMap.@nonstandard\n\n\nChainMap.@push_block\n\n\nChainMap.@unweave\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\ntype Arguments\n    positional::Tuple\n    keyword::DataStrucutes.OrderedDict{Symbol, Any}\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use. Create with \ncollect_arguments\n. You can also \nmerge\n two \nArguments\n, \npush\n or \nunshift\n in new arguments, and run with \nrun\n.\n\n\nsource\n\n\n#\n\n\nChainMap.LazyCall\n \n \nType\n.\n\n\ntype LazyCall{T \n: Function}\n    arguments::Arguments\n    function_call::T\nend\n\n\n\n\n\nWill store a function along with its arguments for later use. Create with \ncollect_call\n and run with \nrun\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments, f::Function)\n\n\n\n\n\nCall \nf\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\nvcat\n)\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments)\n\n\n\n\n\nCall \nrun\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\nvcat\n)\n\n    \ncollect_arguments\n(\nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall, f::Function)\n\n\n\n\n\nInsert \nl.function_call\n as the first positional argument in \nl.arguments\n, the standard position for functional programming, then call \nf\n on the result.\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n4\n])\n\n    \nLazyCall\n(\nvcat\n)\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall)\n\n\n\n\n\nCall \nl.function_call\n on the \nArguments\n in \nl.arguments\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\nvcat\n)\n\n    \nLazyCall\n(\nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.arguments_block\n \n \nMethod\n.\n\n\n@arguments_block(es...)\n\n\n\n\n\nWill break up any begin blocks in \nes\n into lines, create keyword arguments from assignments, and feed all arguments to \ncollect_arguments\n\n\nExamples\n\n\narguments_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \n@\narguments_block\n \nbegin\n\n        \n2\n\n        \na\n \n=\n \n3\n\n    \nend\n\n\nend\n\n\n\n@\ntest\n \narguments_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@unweave\n\n\nExamples\n\n\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain es...\n\n\n\n\n\nReduce \n@chain\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \nvcat\n(\n3\n)\n \n)\n \n==\n\n    \n@\nchain\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \nvcat\n(\n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain on_that call_this\n\n\n\n\n\nCall \ncall_this\n on \non_that\n\n\nExamples\n\n\n@\ntest\n \nvcat\n(\n1\n)\n \n==\n \n@\nchain\n \n1\n \nvcat\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain insert_this into_that::Expr\n\n\n\n\n\n@chain\n always reinterprets \n_\n in \ninto_that\n as \ninsert_this\n.\n\n\nIf\n\n\n\n\ninto_that\n can be recognized as a function call or a macro call, and\n\n\nbare \n_\n is not a positional argument, assigned to a keyword, or splatted   before or after \n;\n\n\n\n\n_\n will be inserted as the first argument to \ninto_that\n.\n\n\nTo prevent insertion into the first argument, but still reinterpret \n_\n, wrap \ninto_that\n in a \nbegin\n block.\n\n\nExamples\n\n\n@\ntest\n \nvcat\n(\n1\n,\n \n2\n)\n \n==\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n\n\n\n@\ntest\n \nvcat\n(\n2\n,\n \n1\n)\n \n==\n \n@\nchain\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n\n\n\n@\ntest\n \nvcat\n(\n3\n,\n \n2\n,\n \n1\n)\n \n==\n \n@\nchain\n \n(\n2\n,\n \n1\n)\n \nvcat\n(\n3\n,\n \n_\n...\n)\n\n\n\n@\ntest\n \n0\n \n==\n \n@\nchain\n \n1\n \nbegin\n \n-\n(\n3\n,\n \n2\n \n+\n \n_\n)\n \nend\n\n\n\nkeyword_test\n(;\n \nkeyword_arguments\n...\n)\n \n=\n \nkeyword_arguments\n\n\n\n@\ntest\n \nkeyword_test\n(\na\n \n=\n \n1\n)\n \n==\n \n@\nchain\n \n1\n \nkeyword_test\n(\na\n \n=\n \n_\n)\n\n\n\n@\ntest\n \nkeyword_test\n(\nb\n \n=\n \n2\n,\n \na\n \n=\n \n1\n)\n \n==\n\n    \n@\nchain\n \nkeyword_test\n(\na\n \n=\n \n1\n)\n \nkeyword_test\n(\nb\n \n=\n \n2\n;\n \n_\n...\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain e::Expr\n\n\n\n\n\nSeparate single begin blocks out into lines and recur. Return single non-blocks.\n\n\nExamples\n\n\n@\ntest\n \n1\n \n==\n \n@\nchain\n \n1\n\n\n\nchain_block\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \nvcat\n(\n2\n)\n\n\nend\n\n\n\n@\ntest\n \nchain_block\n \n==\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_arguments\n \n \nMethod\n.\n\n\ncollect_arguments(positional...; keyword...)\n\n\n\n\n\nEasy way to build an \nArguments\n type.\n\n\nExamples\n\n\na\n \n=\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n@\ntest\n \na\n.\npositional\n \n==\n \n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \na\n.\nkeyword\n \n==\n \nDataStructures\n.\nOrderedDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_call\n \n \nMethod\n.\n\n\ncollect_call\n(\nf\n:\n:Function\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nEasy way to build a \nLazyCall\n type.\n\n\nExamples\n\n\nl\n \n=\n \ncollect_call\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n@\ntest\n \nl\n.\nfunction_call\n \n==\n \nvcat\n\n\n@\ntest\n \nl\n.\narguments\n \n==\n \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lambda\n \n \nMethod\n.\n\n\n@lambda(es...)\n\n\n\n\n\nchain\n together \n(_, es...)\n, then convert to an anonymous function with _ as the input variable.\n\n\nExamples\n\n\nlambda_function\n \n=\n \n@\nlambda\n \nvcat\n(\n2\n)\n \nvcat\n(\n3\n)\n\n\n@\ntest\n \nlambda_function\n(\n1\n)\n \n==\n \nvcat\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n\nlambda_function_2\n \n=\n \n@\nlambda\n \n-\n(\n_\n,\n \n1\n)\n\n\n@\ntest\n \nlambda_function_2\n(\n2\n)\n \n==\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lazy_call\n \n \nMethod\n.\n\n\n@lazy_call(e)\n\n\n\n\n\nWill break apart a function call into a \nLazyCall\n object.\n\n\nExamples\n\n\ntest_function\n(\narguments\n...\n;\n \nkeyword_arguments\n...\n)\n \n=\n\n    \n(\narguments\n,\n \nkeyword_arguments\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \ntest_function\n(\n1\n,\n \n2\n,\n \na\n=\n \n3\n)\n \n)\n \n==\n\n    \ncollect_call\n(\ntest_function\n,\n \n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.nonstandard\n \n \nMethod\n.\n\n\n@nonstandard(fs...)\n\n\n\n\n\nWill create a nonstandard evaluation macro for each of the \nfs\n functions.\n\n\nEach function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.\n\n\nExamples\n\n\nbinaryfun\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nb\n(\n$\na\n,\n \n$\nc\n))\n\n\nchainback\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nc\n(\n$\nb\n,\n \n$\na\n))\n\n\n\n@\nnonstandard\n \nbinaryfun\n \nchainback\n\n\n\n@\ntest\n \nvcat\n(\n1\n,\n \n2\n)\n \n==\n \n@\nbinaryfun\n \n1\n \nvcat\n \n2\n\n\n@\ntest\n \nvcat\n(\n3\n,\n \n2\n)\n \n==\n \n@\nchainback\n \n2\n \n3\n \nvcat\n\n\n\nSee documentation of [`binaryfun`](@ref)\n \n==\n\n    \n@\nchain\n \n(@\ndoc\n \n@\nbinaryfun\n)\n \nstring\n \nchomp\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to an already existing \nArguments\n type.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \npush\n(\n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push_block\n \n \nMethod\n.\n\n\n@push_block(es...)\n\n\n\n\n\nWill break up any begin blocks in \nes\n, create keyword arguments from assignments, and feed them to \npush\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \ncollect_arguments\n\n    \n@\npush_block\n \nbegin\n\n        \n2\n\n        \na\n \n=\n \n3\n\n    \nend\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \n@\nchain\n \n1\n \ncollect_arguments\n \npush\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to an already existing \nArguments\n type.\n\n\nNew arguments are added at the start.\n\n\nExamples\n\n\nunshift_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n    \nunshift\n(\n1\n)\n\n\nend\n\n\n\n@\ntest\n \nunshift_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n @unweave(insert_this, into_that)\n\n\n\n\n\nMark \ninsert_this\n with a tilda, \nchain\n it \ninto_that\n, and \nunweave\n the result.\n\n\nExamples\n\n\nA\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nB\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\nunweave_test\n \n=\n \n@\nchain\n \nbegin\n\n    \nA\n\n    \n@\nunweave\n \nvcat\n(\n~\n[\n3\n,\n \n4\n],\n \n~\n(\nB\n...\n)\n \n)\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nunweave_test\n \n==\n\n      \nmap\n((\na\n,\n \nc\n,\n \nb\n...\n)\n \n-\n \nvcat\n(\na\n,\n \nc\n,\n \nb\n...\n),\n \nA\n,\n \n[\n3\n,\n \n4\n],\n \nB\n...\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave e\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. No more than one splatted positional argument can be woven in. No more than one splatted keyword argument can be woven in provided there is a \n;\n visible both inside and outside the tilda. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\nA\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nB\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\nunweave_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n@\nunweave\n \nvcat\n(\n~\nA\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nB\n...\n)\n \n)\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nunweave_test\n \n==\n\n      \nmap\n((\na\n,\n \nc\n,\n \nb\n...\n)\n \n-\n \nvcat\n(\na\n,\n \nc\n,\n \nb\n...\n),\n \nA\n,\n \n[\n3\n,\n \n4\n],\n \nB\n...\n)\n\n\n\nkeyword_test\n(;\n \nkeyword_arguments\n...\n)\n \n=\n \nkeyword_arguments\n\n\n\na\n \n=\n \nkeyword_test\n(\na\n \n=\n \n1\n,\n \nb\n \n=\n \n2\n)\n\n\n\nunweave_keyword_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n@\nunweave\n \nkeyword_test\n(;\n \nc\n \n=\n \n3\n,\n \n~\n(;\n \na\n...\n))\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nunweave_keyword_test\n \n==\n \nkeyword_test\n(\nc\n \n=\n \n3\n;\n \na\n...\n \n)\n\n\n\n# Can splat no more than one positional argument\n\n\n@\ntest_throws\n \nErrorException\n \nChainMap\n.\nunweave\n(:(\n \n~\n(\na\n...\n)\n \n+\n \n~\n(\nb\n...\n)\n \n))\n\n\n# Can splat no more than one keyword argument\n\n\n@\ntest_throws\n \nErrorException\n \nChainMap\n.\nunweave\n(:(\n \n~\n(;\na\n...\n)\n \n+\n \n~\n(;\nb\n...\n)\n \n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@arguments_block\n \n \nMacro\n.\n\n\nSee documentation of \narguments_block\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\nSee documentation of \nchain\n\n\nsource\n\n\n#\n\n\nChainMap.@lambda\n \n \nMacro\n.\n\n\nSee documentation of \nlambda\n\n\nsource\n\n\n#\n\n\nChainMap.@lazy_call\n \n \nMacro\n.\n\n\nSee documentation of \nlazy_call\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\nSee documentation of \nnonstandard\n\n\nsource\n\n\n#\n\n\nChainMap.@push_block\n \n \nMacro\n.\n\n\nSee documentation of \npush_block\n\n\nsource\n\n\n#\n\n\nChainMap.@unweave\n \n \nMacro\n.\n\n\nSee documentation of \nunweave\n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nmerge(a::Arguments, b::Arguments)\n\n\n\n\n\nMerge two \nArguments\n types.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\nmerge_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \nmerge\n(\ncollect_arguments\n(\n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n \n)\n\n\nend\n\n\n\n@\ntest\n \nmerge_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl", 
            "text": "ChainMap.Arguments  ChainMap.LazyCall  Base.merge  Base.run  Base.run  Base.run  Base.run  ChainMap.arguments_block  ChainMap.bitnot  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.collect_arguments  ChainMap.collect_call  ChainMap.lambda  ChainMap.lazy_call  ChainMap.nonstandard  ChainMap.push  ChainMap.push_block  ChainMap.unshift  ChainMap.unweave  ChainMap.unweave  ChainMap.@arguments_block  ChainMap.@chain  ChainMap.@lambda  ChainMap.@lazy_call  ChainMap.@nonstandard  ChainMap.@push_block  ChainMap.@unweave   #  ChainMap.Arguments     Type .  type Arguments\n    positional::Tuple\n    keyword::DataStrucutes.OrderedDict{Symbol, Any}\nend  Will store positional and keyword arguments for later use. Create with  collect_arguments . You can also  merge  two  Arguments ,  push  or  unshift  in new arguments, and run with  run .  source  #  ChainMap.LazyCall     Type .  type LazyCall{T  : Function}\n    arguments::Arguments\n    function_call::T\nend  Will store a function along with its arguments for later use. Create with  collect_call  and run with  run  source  #  Base.run     Method .   run(a::Arguments, f::Function)  Call  f  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( vcat ) \n     run ( map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(a::Arguments)  Call  run  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( vcat ) \n     collect_arguments ( map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall, f::Function)  Insert  l.function_call  as the first positional argument in  l.arguments , the standard position for functional programming, then call  f  on the result.  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 , 4 ]) \n     LazyCall ( vcat ) \n     run ( map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall)  Call  l.function_call  on the  Arguments  in  l.arguments  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( vcat ) \n     LazyCall ( map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.arguments_block     Method .  @arguments_block(es...)  Will break up any begin blocks in  es  into lines, create keyword arguments from assignments, and feed all arguments to  collect_arguments  Examples  arguments_test   =   @ chain   begin \n     1 \n     @ arguments_block   begin \n         2 \n         a   =   3 \n     end  end  @ test   arguments_test   ==   collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @unweave  Examples  @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.chain     Method .  @chain es...  Reduce  @chain  over  es  Examples  @ test   (   @ chain   1   vcat ( 2 )   vcat ( 3 )   )   == \n     @ chain   (   @ chain   1   vcat ( 2 )   )   vcat ( 3 )   source  #  ChainMap.chain     Method .  @chain on_that call_this  Call  call_this  on  on_that  Examples  @ test   vcat ( 1 )   ==   @ chain   1   vcat   source  #  ChainMap.chain     Method .  @chain insert_this into_that::Expr  @chain  always reinterprets  _  in  into_that  as  insert_this .  If   into_that  can be recognized as a function call or a macro call, and  bare  _  is not a positional argument, assigned to a keyword, or splatted   before or after  ;   _  will be inserted as the first argument to  into_that .  To prevent insertion into the first argument, but still reinterpret  _ , wrap  into_that  in a  begin  block.  Examples  @ test   vcat ( 1 ,   2 )   ==   @ chain   1   vcat ( 2 )  @ test   vcat ( 2 ,   1 )   ==   @ chain   1   vcat ( 2 ,   _ )  @ test   vcat ( 3 ,   2 ,   1 )   ==   @ chain   ( 2 ,   1 )   vcat ( 3 ,   _ ... )  @ test   0   ==   @ chain   1   begin   - ( 3 ,   2   +   _ )   end  keyword_test (;   keyword_arguments ... )   =   keyword_arguments  @ test   keyword_test ( a   =   1 )   ==   @ chain   1   keyword_test ( a   =   _ )  @ test   keyword_test ( b   =   2 ,   a   =   1 )   == \n     @ chain   keyword_test ( a   =   1 )   keyword_test ( b   =   2 ;   _ ... )   source  #  ChainMap.chain     Method .  @chain e::Expr  Separate single begin blocks out into lines and recur. Return single non-blocks.  Examples  @ test   1   ==   @ chain   1  chain_block   =   @ chain   begin \n     1 \n     vcat ( 2 )  end  @ test   chain_block   ==   @ chain   1   vcat ( 2 )   source  #  ChainMap.collect_arguments     Method .  collect_arguments(positional...; keyword...)  Easy way to build an  Arguments  type.  Examples  a   =   collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  @ test   a . positional   ==   ( 1 ,   2 )  @ test   a . keyword   ==   DataStructures . OrderedDict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  ChainMap.collect_call     Method .  collect_call ( f : :Function ,   positional ...;   keyword ...)   Easy way to build a  LazyCall  type.  Examples  l   =   collect_call ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])  @ test   l . function_call   ==   vcat  @ test   l . arguments   ==   collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.lambda     Method .  @lambda(es...)  chain  together  (_, es...) , then convert to an anonymous function with _ as the input variable.  Examples  lambda_function   =   @ lambda   vcat ( 2 )   vcat ( 3 )  @ test   lambda_function ( 1 )   ==   vcat ( 1 ,   2 ,   3 )  lambda_function_2   =   @ lambda   - ( _ ,   1 )  @ test   lambda_function_2 ( 2 )   ==   1   source  #  ChainMap.lazy_call     Method .  @lazy_call(e)  Will break apart a function call into a  LazyCall  object.  Examples  test_function ( arguments ... ;   keyword_arguments ... )   = \n     ( arguments ,   keyword_arguments )  @ test   (   @ lazy_call   test_function ( 1 ,   2 ,   a =   3 )   )   == \n     collect_call ( test_function ,   1 ,   2 ,   a   =   3 )   source  #  ChainMap.nonstandard     Method .  @nonstandard(fs...)  Will create a nonstandard evaluation macro for each of the  fs  functions.  Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.  Examples  binaryfun ( a ,   b ,   c )   =   :( $ b ( $ a ,   $ c ))  chainback ( a ,   b ,   c )   =   :( $ c ( $ b ,   $ a ))  @ nonstandard   binaryfun   chainback  @ test   vcat ( 1 ,   2 )   ==   @ binaryfun   1   vcat   2  @ test   vcat ( 3 ,   2 )   ==   @ chainback   2   3   vcat  See documentation of [`binaryfun`](@ref)   == \n     @ chain   (@ doc   @ binaryfun )   string   chomp   source  #  ChainMap.push     Method .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to an already existing  Arguments  type.  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  push_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     push ( 4 ,   a   =   5 ,   c   =   6 )  end  @ test   push_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source  #  ChainMap.push_block     Method .  @push_block(es...)  Will break up any begin blocks in  es , create keyword arguments from assignments, and feed them to  push  Examples  push_test   =   @ chain   begin \n     1 \n     collect_arguments \n     @ push_block   begin \n         2 \n         a   =   3 \n     end  end  @ test   push_test   ==   @ chain   1   collect_arguments   push ( 2 ,   a   =   3 )   source  #  ChainMap.unshift     Method .  unshift(arguments::Arguments, positional...)  Add positional arguments to an already existing  Arguments  type.  New arguments are added at the start.  Examples  unshift_test   =   @ chain   begin \n     collect_arguments ( 2 ,   a   =   3 ) \n     unshift ( 1 )  end  @ test   unshift_test   ==   collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.unweave     Method .   @unweave(insert_this, into_that)  Mark  insert_this  with a tilda,  chain  it  into_that , and  unweave  the result.  Examples  A   =   [ 1 ,   2 ]  B   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  unweave_test   =   @ chain   begin \n     A \n     @ unweave   vcat ( ~ [ 3 ,   4 ],   ~ ( B ... )   ) \n     run ( map )  end  @ test   unweave_test   == \n       map (( a ,   c ,   b ... )   -   vcat ( a ,   c ,   b ... ),   A ,   [ 3 ,   4 ],   B ... )   source  #  ChainMap.unweave     Method .  @unweave e  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. No more than one splatted positional argument can be woven in. No more than one splatted keyword argument can be woven in provided there is a  ;  visible both inside and outside the tilda. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot .  Examples  A   =   [ 1 ,   2 ]  B   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  unweave_test   =   @ chain   begin \n     @ unweave   vcat ( ~ A ,   ~ [ 3 ,   4 ],   ~ ( B ... )   ) \n     run ( map )  end  @ test   unweave_test   == \n       map (( a ,   c ,   b ... )   -   vcat ( a ,   c ,   b ... ),   A ,   [ 3 ,   4 ],   B ... )  keyword_test (;   keyword_arguments ... )   =   keyword_arguments  a   =   keyword_test ( a   =   1 ,   b   =   2 )  unweave_keyword_test   =   @ chain   begin \n     @ unweave   keyword_test (;   c   =   3 ,   ~ (;   a ... )) \n     run  end  @ test   unweave_keyword_test   ==   keyword_test ( c   =   3 ;   a ...   )  # Can splat no more than one positional argument  @ test_throws   ErrorException   ChainMap . unweave (:(   ~ ( a ... )   +   ~ ( b ... )   ))  # Can splat no more than one keyword argument  @ test_throws   ErrorException   ChainMap . unweave (:(   ~ (; a ... )   +   ~ (; b ... )   ))   source  #  ChainMap.@arguments_block     Macro .  See documentation of  arguments_block  source  #  ChainMap.@chain     Macro .  See documentation of  chain  source  #  ChainMap.@lambda     Macro .  See documentation of  lambda  source  #  ChainMap.@lazy_call     Macro .  See documentation of  lazy_call  source  #  ChainMap.@nonstandard     Macro .  See documentation of  nonstandard  source  #  ChainMap.@push_block     Macro .  See documentation of  push_block  source  #  ChainMap.@unweave     Macro .  See documentation of  unweave  source  #  Base.merge     Method .  merge(a::Arguments, b::Arguments)  Merge two  Arguments  types.  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  merge_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     merge ( collect_arguments ( 4 ,   a   =   5 ,   c   =   6 )   )  end  @ test   merge_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source", 
            "title": "ChainMap.jl"
        }
    ]
}