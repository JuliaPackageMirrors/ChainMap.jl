{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl\n\n\n\n\nChainMap.Arguments\n\n\nChainMap.Arguments\n\n\nChainMap.LazyCall\n\n\nBase.merge\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nChainMap.arguments_block\n\n\nChainMap.bitnot\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.collect_arguments\n\n\nChainMap.collect_call\n\n\nChainMap.lazy_call\n\n\nChainMap.nonstandard\n\n\nChainMap.push\n\n\nChainMap.push_block\n\n\nChainMap.unshift\n\n\nChainMap.unweave\n\n\nChainMap.@arguments_block\n\n\nChainMap.@chain\n\n\nChainMap.@lazy_call\n\n\nChainMap.@nonstandard\n\n\nChainMap.@push_block\n\n\nChainMap.@unweave\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\ntype Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use. Create with \ncollect_arguments\n. You can also \nmerge\n to \nArguments\n, \npush\n or \nunshift\n in new arguments, and run with \nrun\n.\n\n\nsource\n\n\n#\n\n\nChainMap.Arguments\n \n \nMethod\n.\n\n\nArguments(positional::Tuple, keyword::Vector)\n\n\n\n\n\nConvert \nkeyword\n to a \nDict\n before creating am \nArguments\n type.\n\n\nsource\n\n\n#\n\n\nChainMap.LazyCall\n \n \nType\n.\n\n\ntype LazyCall{T \n: Function}\n    arguments::Arguments\n    function_call::T\nend\n\n\n\n\n\nWill store a function along with its arguments for later use. Create with \ncollect_call\n(@ref) and run with \nrun\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments, f::Function)\n\n\n\n\n\nCall \nf\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\nvcat\n)\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments)\n\n\n\n\n\nCall \nrun\n on the \nArguments\n in \na\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\nvcat\n)\n\n    \ncollect_arguments\n(\nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall, f::Function)\n\n\n\n\n\nInsert \nl.function\n as the first positional argument in \nl.arguments\n, the standard position for functional programming, then call \nf\n on the result.\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n4\n])\n\n    \nLazyCall\n(\nvcat\n)\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall)\n\n\n\n\n\nCall \nl.function_call\n on the \nArguments\n in \nl.arguments\n\n\nExamples\n\n\nrun_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n    \nunshift\n(\nvcat\n)\n\n    \nLazyCall\n(\nmap\n)\n\n    \nrun\n\n\nend\n\n\n\n@\ntest\n \nrun_test\n \n==\n \nmap\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@unweave\n\n\nExamples\n\n\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_arguments\n \n \nMethod\n.\n\n\ncollect_arguments(positional...; keyword...)\n\n\n\n\n\nEasy way to build an \nArguments\n type.\n\n\nExamples\n\n\na\n \n=\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n@\ntest\n \na\n.\npositional\n \n==\n \n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \na\n.\nkeyword\n \n==\n \nDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_call\n \n \nMethod\n.\n\n\ncollect_call\n(\nf\n:\n:Function\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nEasy way to build a \nLazyCall\n type.\n\n\nExamples\n\n\nl\n \n=\n \ncollect_call\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n@\ntest\n \nl\n.\nfunction_call\n \n==\n \nvcat\n\n\n@\ntest\n \nl\n.\narguments\n \n==\n \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to an already existing \nArguments\n type.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \npush\n(\n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to an already existing \nArguments\n type.\n\n\nNew arguments are added at the start.\n\n\nExamples\n\n\nunshift_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n    \nunshift\n(\n1\n)\n\n\nend\n\n\n\n@\ntest\n \nunshift_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@arguments_block\n \n \nMacro\n.\n\n\nSee documentation of \narguments_block\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\nSee documentation of \nchain\n\n\nsource\n\n\n#\n\n\nChainMap.@lazy_call\n \n \nMacro\n.\n\n\nSee documentation of \nlazy_call\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\nSee documentation of \nnonstandard\n\n\nsource\n\n\n#\n\n\nChainMap.@push_block\n \n \nMacro\n.\n\n\nSee documentation of \npush_block\n\n\nsource\n\n\n#\n\n\nChainMap.@unweave\n \n \nMacro\n.\n\n\nSee documentation of \nunweave\n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nmerge(a::Arguments, b::Arguments)\n\n\n\n\n\nMerge two \nArguments\n types.\n\n\nPositional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\nmerge_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n)\n\n    \nmerge\n(\ncollect_arguments\n(\n4\n,\n \na\n \n=\n \n5\n,\n \nc\n \n=\n \n6\n)\n \n)\n\n\nend\n\n\n\n@\ntest\n \nmerge_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n4\n,\n \na\n \n=\n \n5\n,\n \nb\n \n=\n \n3\n,\n \nc\n \n=\n \n6\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.arguments_block\n \n \nMethod\n.\n\n\n@arguments_block(es...)\n\n\n\n\n\nWill break up any begin blocks in \nes\n into lines, create keyword arguments from assignments, and feed all arguments to \ncollect_arguments\n\n\nExamples\n\n\narguments_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \n@\narguments_block\n \nbegin\n\n        \n2\n\n        \na\n \n=\n \n3\n\n    \nend\n\n\nend\n\n\n\n@\ntest\n \narguments_test\n \n==\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain es...\n\n\n\n\n\nReduce \n@chain\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \nvcat\n(\n3\n)\n \n)\n \n==\n\n      \n(\n \n@\nchain\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \nvcat\n(\n3\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail\n\n\n\n\n\nCall \ntail\n on \nhead\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \n1\n \nvcat\n)\n \n==\n \nvcat\n(\n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail::Expr\n\n\n\n\n\n@chain\n always reinterprets \n_\n in \ntail\n as \nhead\n.\n\n\nIf\n\n\n\n\ntail can be recognized as a function call or a macro call, and\n\n\nneither bare \n_\n nor \n_...\n is a positional argument to \ntail\n\n\n\n\n_\n will be inserted as the first argument to \ntail\n.\n\n\nTo prevent insertion into the first argument, but still reinterpret \n_\n, wrap \ntail\n in a \nbegin\n block.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \n==\n\n      \nvcat\n(\n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n \n)\n \n==\n\n      \nvcat\n(\n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n(\n2\n,\n \n1\n)\n \nvcat\n(\n3\n,\n \n_\n...\n)\n \n)\n \n==\n\n      \nvcat\n(\n3\n,\n \n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nbegin\n \n-\n(\n3\n,\n \n2\n \n+\n \n_\n)\n \nend\n \n)\n \n==\n \n0\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain e::Expr\n\n\n\n\n\nSeparate single begin blocks out into lines and recur.\n\n\nThrows an error if \ne\n is not a begin block.\n\n\nExamples\n\n\nchain_block\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \nvcat\n(\n2\n)\n\n\nend\n\n\n\n@\ntest\n \nchain_block\n \n==\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n\n\n\n# Cannot chain only one argument\n\n\n@\ntest_throws\n \nErrorException\n \nChainMap\n.\nchain\n(:(\n1\n \n+\n \n1\n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lazy_call\n \n \nMethod\n.\n\n\n@lazy_call(e)\n\n\n\n\n\nWill break apart a function call into a \nLazyCall\n object. Cannot handle keyword arguments at the moment.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \n+\n(\n1\n,\n \n2\n)\n \n)\n \n==\n \ncollect_call\n(\n+\n,\n \n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n(\n1\n)\n \n)\n \n==\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.nonstandard\n \n \nMethod\n.\n\n\n@nonstandard(fs...)\n\n\n\n\n\nWill create a nonstandard evaluation macro for each of the \nfs\n functions.\n\n\nEach function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.\n\n\nExamples\n\n\nbinaryfun\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nb\n(\n$\na\n,\n \n$\nc\n))\n\n\nchainback\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nc\n(\n$\nb\n,\n \n$\na\n))\n\n\n\n@\nnonstandard\n \nbinaryfun\n \nchainback\n\n\n\n@\ntest\n \n(@\nbinaryfun\n \n1\n \nvcat\n \n2\n)\n \n==\n \nvcat\n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \n(@\nchainback\n \n2\n \n3\n \nvcat\n)\n \n==\n \nvcat\n(\n3\n,\n \n2\n)\n\n\n\n@\ntest\n \n(@\nchain\n \n(@\ndoc\n \n@\nbinaryfun\n)\n \nstring\n \nchomp\n)\n \n==\n\n      \nSee documentation of [`binaryfun`](@ref)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push_block\n \n \nMethod\n.\n\n\n@push_block(es...)\n\n\nWill break up any begin blocks in \nes\n, create keyword arguments from assignments, and feed them to \npush\n\n\nExamples\n\n\npush_test\n \n=\n \n@\nchain\n \nbegin\n\n    \n1\n\n    \ncollect_arguments\n\n    \n@\npush_block\n \nbegin\n\n        \n2\n\n        \na\n \n=\n \n3\n\n    \nend\n\n\nend\n\n\n\n@\ntest\n \npush_test\n \n==\n \npush\n(\ncollect_arguments\n(\n1\n),\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave e\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. You can also weave in \nonly one\n splatted argument. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\nfancy\n \n=\n \n@\nchain\n \nbegin\n\n    \na\n\n    \nbegin\n \n@\nunweave\n \nvcat\n(\n~\n_\n,\n \n~\n_\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nb\n...\n)\n \n)\n \nend\n\n    \nrun\n(\nmap\n)\n\n\nend\n\n\n\nboring\n \n=\n \nmap\n((\na\n,\n \nc\n,\n \nb\n...\n)\n \n-\n \nvcat\n(\na\n,\n \na\n,\n \nc\n,\n \nb\n...\n),\n \na\n,\n \n[\n3\n,\n \n4\n],\n \nb\n...\n)\n\n\n\n@\ntest\n \nfancy\n \n==\n \nboring\n\n\n\n# No arguments marked with tildas detected\n\n\n@\ntest_throws\n \nErrorException\n \nChainMap\n.\nunweave\n(:(\n \n1\n \n+\n \n1\n \n))\n\n\n# Cannot include more than one splatted argument\n\n\n@\ntest_throws\n \nErrorException\n \nChainMap\n.\nunweave\n(:(\n \n~\n(\na\n...\n)\n \n+\n \n~\n(\nb\n...\n)\n \n))\n\n\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl", 
            "text": "ChainMap.Arguments  ChainMap.Arguments  ChainMap.LazyCall  Base.merge  Base.run  Base.run  Base.run  Base.run  ChainMap.arguments_block  ChainMap.bitnot  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.collect_arguments  ChainMap.collect_call  ChainMap.lazy_call  ChainMap.nonstandard  ChainMap.push  ChainMap.push_block  ChainMap.unshift  ChainMap.unweave  ChainMap.@arguments_block  ChainMap.@chain  ChainMap.@lazy_call  ChainMap.@nonstandard  ChainMap.@push_block  ChainMap.@unweave   #  ChainMap.Arguments     Type .  type Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend  Will store positional and keyword arguments for later use. Create with  collect_arguments . You can also  merge  to  Arguments ,  push  or  unshift  in new arguments, and run with  run .  source  #  ChainMap.Arguments     Method .  Arguments(positional::Tuple, keyword::Vector)  Convert  keyword  to a  Dict  before creating am  Arguments  type.  source  #  ChainMap.LazyCall     Type .  type LazyCall{T  : Function}\n    arguments::Arguments\n    function_call::T\nend  Will store a function along with its arguments for later use. Create with  collect_call (@ref) and run with  run  source  #  Base.run     Method .   run(a::Arguments, f::Function)  Call  f  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( vcat ) \n     run ( map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(a::Arguments)  Call  run  on the  Arguments  in  a  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( vcat ) \n     collect_arguments ( map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall, f::Function)  Insert  l.function  as the first positional argument in  l.arguments , the standard position for functional programming, then call  f  on the result.  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 , 4 ]) \n     LazyCall ( vcat ) \n     run ( map )  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  Base.run     Method .   run(l::LazyCall)  Call  l.function_call  on the  Arguments  in  l.arguments  Examples  run_test   =   @ chain   begin \n     collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ]) \n     unshift ( vcat ) \n     LazyCall ( map ) \n     run  end  @ test   run_test   ==   map ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @unweave  Examples  @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.collect_arguments     Method .  collect_arguments(positional...; keyword...)  Easy way to build an  Arguments  type.  Examples  a   =   collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  @ test   a . positional   ==   ( 1 ,   2 )  @ test   a . keyword   ==   Dict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  ChainMap.collect_call     Method .  collect_call ( f : :Function ,   positional ...;   keyword ...)   Easy way to build a  LazyCall  type.  Examples  l   =   collect_call ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ])  @ test   l . function_call   ==   vcat  @ test   l . arguments   ==   collect_arguments ([ 1 ,   2 ],   [ 3 ,   4 ])   source  #  ChainMap.push     Method .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to an already existing  Arguments  type.  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  push_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     push ( 4 ,   a   =   5 ,   c   =   6 )  end  @ test   push_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source  #  ChainMap.unshift     Method .  unshift(arguments::Arguments, positional...)  Add positional arguments to an already existing  Arguments  type.  New arguments are added at the start.  Examples  unshift_test   =   @ chain   begin \n     collect_arguments ( 2 ,   a   =   3 ) \n     unshift ( 1 )  end  @ test   unshift_test   ==   collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.@arguments_block     Macro .  See documentation of  arguments_block  source  #  ChainMap.@chain     Macro .  See documentation of  chain  source  #  ChainMap.@lazy_call     Macro .  See documentation of  lazy_call  source  #  ChainMap.@nonstandard     Macro .  See documentation of  nonstandard  source  #  ChainMap.@push_block     Macro .  See documentation of  push_block  source  #  ChainMap.@unweave     Macro .  See documentation of  unweave  source  #  Base.merge     Method .  merge(a::Arguments, b::Arguments)  Merge two  Arguments  types.  Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  merge_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   2 ,   b   =   3 ) \n     merge ( collect_arguments ( 4 ,   a   =   5 ,   c   =   6 )   )  end  @ test   merge_test   ==   collect_arguments ( 1 ,   4 ,   a   =   5 ,   b   =   3 ,   c   =   6 )   source  #  ChainMap.arguments_block     Method .  @arguments_block(es...)  Will break up any begin blocks in  es  into lines, create keyword arguments from assignments, and feed all arguments to  collect_arguments  Examples  arguments_test   =   @ chain   begin \n     1 \n     @ arguments_block   begin \n         2 \n         a   =   3 \n     end  end  @ test   arguments_test   ==   collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.chain     Method .  @chain es...  Reduce  @chain  over  es  Examples  @ test   (   @ chain   1   vcat ( 2 )   vcat ( 3 )   )   == \n       (   @ chain   (   @ chain   1   vcat ( 2 )   )   vcat ( 3 )   )   source  #  ChainMap.chain     Method .  @chain head tail  Call  tail  on  head  Examples  @ test   (@ chain   1   vcat )   ==   vcat ( 1 )   source  #  ChainMap.chain     Method .  @chain head tail::Expr  @chain  always reinterprets  _  in  tail  as  head .  If   tail can be recognized as a function call or a macro call, and  neither bare  _  nor  _...  is a positional argument to  tail   _  will be inserted as the first argument to  tail .  To prevent insertion into the first argument, but still reinterpret  _ , wrap  tail  in a  begin  block.  Examples  @ test   (   @ chain   1   vcat ( 2 )   )   == \n       vcat ( 1 ,   2 )  @ test   (   @ chain   1   vcat ( 2 ,   _ )   )   == \n       vcat ( 2 ,   1 )  @ test   (   @ chain   ( 2 ,   1 )   vcat ( 3 ,   _ ... )   )   == \n       vcat ( 3 ,   2 ,   1 )  @ test   (   @ chain   1   begin   - ( 3 ,   2   +   _ )   end   )   ==   0   source  #  ChainMap.chain     Method .  @chain e::Expr  Separate single begin blocks out into lines and recur.  Throws an error if  e  is not a begin block.  Examples  chain_block   =   @ chain   begin \n     1 \n     vcat ( 2 )  end  @ test   chain_block   ==   @ chain   1   vcat ( 2 )  # Cannot chain only one argument  @ test_throws   ErrorException   ChainMap . chain (:( 1   +   1 ))   source  #  ChainMap.lazy_call     Method .  @lazy_call(e)  Will break apart a function call into a  LazyCall  object. Cannot handle keyword arguments at the moment.  Examples  @ test   (   @ lazy_call   + ( 1 ,   2 )   )   ==   collect_call ( + ,   1 ,   2 )  @ test   (   @ lazy_call ( 1 )   )   ==   1   source  #  ChainMap.nonstandard     Method .  @nonstandard(fs...)  Will create a nonstandard evaluation macro for each of the  fs  functions.  Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will write a docstring for the nonstandard version pointing to the documentation of the standard version.  Examples  binaryfun ( a ,   b ,   c )   =   :( $ b ( $ a ,   $ c ))  chainback ( a ,   b ,   c )   =   :( $ c ( $ b ,   $ a ))  @ nonstandard   binaryfun   chainback  @ test   (@ binaryfun   1   vcat   2 )   ==   vcat ( 1 ,   2 )  @ test   (@ chainback   2   3   vcat )   ==   vcat ( 3 ,   2 )  @ test   (@ chain   (@ doc   @ binaryfun )   string   chomp )   == \n       See documentation of [`binaryfun`](@ref)   source  #  ChainMap.push_block     Method .  @push_block(es...)  Will break up any begin blocks in  es , create keyword arguments from assignments, and feed them to  push  Examples  push_test   =   @ chain   begin \n     1 \n     collect_arguments \n     @ push_block   begin \n         2 \n         a   =   3 \n     end  end  @ test   push_test   ==   push ( collect_arguments ( 1 ),   2 ,   a   =   3 )   source  #  ChainMap.unweave     Method .  @unweave e  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. You can also weave in  only one  splatted argument. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot .  Examples  a   =   [ 1 ,   2 ]  b   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  fancy   =   @ chain   begin \n     a \n     begin   @ unweave   vcat ( ~ _ ,   ~ _ ,   ~ [ 3 ,   4 ],   ~ ( b ... )   )   end \n     run ( map )  end  boring   =   map (( a ,   c ,   b ... )   -   vcat ( a ,   a ,   c ,   b ... ),   a ,   [ 3 ,   4 ],   b ... )  @ test   fancy   ==   boring  # No arguments marked with tildas detected  @ test_throws   ErrorException   ChainMap . unweave (:(   1   +   1   ))  # Cannot include more than one splatted argument  @ test_throws   ErrorException   ChainMap . unweave (:(   ~ ( a ... )   +   ~ ( b ... )   ))   source", 
            "title": "ChainMap.jl"
        }
    ]
}