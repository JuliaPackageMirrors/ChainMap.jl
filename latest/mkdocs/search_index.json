{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl\n\n\n\n\nChainMap.Arguments\n\n\nChainMap.Arguments\n\n\nChainMap.LazyCall\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nChainMap.arguments_block\n\n\nChainMap.bitnot\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.collect_arguments\n\n\nChainMap.collect_call\n\n\nChainMap.lazy_call\n\n\nChainMap.nonstandard\n\n\nChainMap.push\n\n\nChainMap.push_block\n\n\nChainMap.unshift\n\n\nChainMap.unweave\n\n\nChainMap.@arguments_block\n\n\nChainMap.@chain\n\n\nChainMap.@lazy_call\n\n\nChainMap.@nonstandard\n\n\nChainMap.@push_block\n\n\nChainMap.@unweave\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\ntype Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use.\n\n\nsource\n\n\n#\n\n\nChainMap.Arguments\n \n \nMethod\n.\n\n\nArguments(positional::Tuple, keyword::Vector)\n\n\n\n\n\nConvert \nkeyword\n to a \nDict\n before creating Arguments type.\n\n\nsource\n\n\n#\n\n\nChainMap.LazyCall\n \n \nType\n.\n\n\ntype LazyCall{T \n: Function}\n    arguments::Arguments\n    function_call::T\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use.\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments, f::Function)\n\n\n\n\n\nCall \nf\n on the arguments in \na\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n;\n \nc\n \n=\n \n4\n)\n \n=\n \na\n \n-\n \nb\n \n+\n \nc\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n                  \nrun\n(\ntest_function\n)\n\n              \nend\n)\n \n==\n\n      \ntest_function\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments)\n\n\n\n\n\nCall \nrun\n on the arguments in \na\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nbegin\n\n                 \ncollect_call\n(\nvcat\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n                 \ncollect_arguments\n(\nmap\n)\n\n                 \nrun\n\n                 \nvcat\n(\n_\n...\n)\n\n             \nend\n)\n \n==\n\n      \n[\n \n1\n,\n \n3\n,\n \n2\n,\n \n4\n \n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall, f::Function)\n\n\n\n\n\nInsert \nl.function\n as the first positional arguments in \nl.arguments\n, the standard position for functional programming, then call \nf\n on the result.\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n[\n3\n,\n4\n])\n\n                  \nLazyCall\n(\nvcat\n)\n\n                  \nrun\n(\nmap\n)\n\n                  \nvcat\n(\n_\n...\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n1\n,\n \n3\n,\n \n2\n,\n \n4\n \n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall)\n\n\n\n\n\nCall \nl.function_call\n on the arguments in \nl.arguments\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n;\n \nc\n \n=\n \n4\n)\n \n=\n \na\n \n-\n \nb\n \n+\n \nc\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n                  \nLazyCall\n(\ntest_function\n)\n\n                  \nrun\n\n              \nend\n)\n \n==\n\n      \ntest_function\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@unweave\n\n\nExamples\n\n\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_arguments\n \n \nMethod\n.\n\n\ncollect_arguments(positional...; keyword...)\n\n\n\n\n\nEasy way to build an \nArguments\n type.\n\n\nExamples\n\n\na\n \n=\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n@\ntest\n \na\n.\npositional\n \n==\n \n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \na\n.\nkeyword\n \n==\n \nDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_call\n \n \nMethod\n.\n\n\ncollect_call\n(\nf\n:\n:Function\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nEasy way to build an \nLazyCall\n type.\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n)\n \n=\n \nvcat\n(\na\n,\n \nb\n)\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_call\n(\ntest_function\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n                  \nrun\n(\nmap\n)\n\n                  \nvcat\n(\n_\n...\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n1\n,\n \n3\n,\n \n2\n,\n \n4\n \n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\narguments_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n3\n)\n\n    \npush\n(\n2\n,\n \nb\n \n=\n \n4\n)\n\n\nend\n\n\n\n@\ntest\n \narguments_test\n \n==\n\n      \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to an already existing arguments type. Arguments are added at the start.\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n                  \nunshift\n(\n1\n)\n\n              \nend\n)\n \n==\n\n            \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@arguments_block\n \n \nMacro\n.\n\n\n@arguments_block(es...)\n\n\n\n\n\nWill break up any begin blocks in \nes\n into lines, create keyword arguments from assignments, and feed all arguments to \ncollect_arguments\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n           \n1\n\n           \n@\narguments_block\n \nbegin\n\n               \n2\n\n               \na\n \n=\n \n3\n \nend\n \nend\n)\n \n==\n\n      \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\n@chain head tail::Expr\n\n\n\n\n\n@chain\n always substitutes \nhead\n into \n_\n in \ntail\n.\n\n\nIf\n\n\n\n\ntail can be recognized as a function call or a macro call, and\n\n\nneither bare \n_\n nor \n_...\n is a positional argument to \ntail\n\n\n\n\n_\n will be first be inserted as the first argument to \ntail\n.\n\n\nTo prevent insertion, wrap \ntail\n in a \nbegin\n block.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \n==\n\n      \nvcat\n(\n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n \n)\n \n==\n\n      \nvcat\n(\n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n(\n2\n,\n \n1\n)\n \nvcat\n(\n3\n,\n \n_\n...\n)\n \n)\n \n==\n\n      \nvcat\n(\n3\n,\n \n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nbegin\n \nvcat\n(\n2\n)\n \nend\n \n)\n \n==\n\n      \nvcat\n(\n2\n)\n\n\n\n\n\n\n@chain head tail\n\n\n\n\n\nCall \ntail\n on \nhead\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \n1\n \nvcat\n)\n \n==\n \nvcat\n(\n1\n)\n\n\n\n\n\n\n@chain e::Expr\n\n\n\n\n\nSeparate single begin blocks out into lines and recur. Return single non-blocks as is.\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \n1\n\n                  \nvcat\n(\n2\n)\n\n               \nend\n)\n \n==\n\n      \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n\n\n\n@\ntest\n \n(@\nchain\n \n1\n \n+\n \n1\n)\n \n==\n \n2\n\n\n\n\n\n\n@chain es...\n\n\n\n\n\nReduce \n@chain\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \nvcat\n(\n3\n)\n \n)\n \n==\n\n      \n(\n \n@\nchain\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \nvcat\n(\n3\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@lazy_call\n \n \nMacro\n.\n\n\n@lazy_call(e)\n\n\n\n\n\nMostly cosmetic; will break apart a function call into a \nLazyCall\n object. Cannot handle keyword arguments at the moment.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \n+\n(\n1\n,\n \n2\n)\n \n)\n \n==\n\n      \ncollect_call\n(\n+\n,\n \n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n(\n1\n)\n \n)\n \n==\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\n@nonstandard(fs...) Will create a nonstandard evaluation macro for each of the fs functions.\n\n\nEach function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will copy over the docstrings from the standard version to the nonstandard version. #Examples\n\n\nbinaryfun\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nb\n(\n$\na\n,\n \n$\nc\n))\n\n\nchainback\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nc\n(\n$\nb\n,\n \n$\na\n))\n\n\n@\nnonstandard\n \nbinaryfun\n \nchainback\n\n\n@\ntest\n \n(@\nbinaryfun\n \n1\n \nvcat\n \n2\n)\n \n==\n \nvcat\n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \n(@\nchainback\n \n2\n \n3\n \nvcat\n)\n \n==\n \nvcat\n(\n3\n,\n \n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@push_block\n \n \nMacro\n.\n\n\n@push_block(es...)\n\n\nWill break up any begin blocks in \nes\n, create keyword arguments from assignments, and feed them to \npush\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n           \ncollect_arguments\n(\n1\n)\n\n           \n@\npush_block\n \nbegin\n\n               \n2\n\n               \na\n \n=\n \n3\n \nend\n \nend\n)\n \n==\n\n      \npush\n(\ncollect_arguments\n(\n1\n),\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@unweave\n \n \nMacro\n.\n\n\n@unweave e\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. You can also weave in \nonly one\n splatted argument. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \n@\nunweave\n \nvcat\n(\n~\na\n,\n \n~\na\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nb\n...\n)\n \n)\n\n                  \nrun\n(\nmap\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n[\n1\n,\n \n1\n,\n \n3\n,\n \n5\n,\n \n7\n],\n \n[\n2\n,\n \n2\n,\n \n4\n,\n \n6\n,\n \n8\n]\n \n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.arguments_block\n \n \nMethod\n.\n\n\n@arguments_block(es...)\n\n\n\n\n\nWill break up any begin blocks in \nes\n into lines, create keyword arguments from assignments, and feed all arguments to \ncollect_arguments\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n           \n1\n\n           \n@\narguments_block\n \nbegin\n\n               \n2\n\n               \na\n \n=\n \n3\n \nend\n \nend\n)\n \n==\n\n      \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain es...\n\n\n\n\n\nReduce \n@chain\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \nvcat\n(\n3\n)\n \n)\n \n==\n\n      \n(\n \n@\nchain\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \nvcat\n(\n3\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail\n\n\n\n\n\nCall \ntail\n on \nhead\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \n1\n \nvcat\n)\n \n==\n \nvcat\n(\n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail::Expr\n\n\n\n\n\n@chain\n always substitutes \nhead\n into \n_\n in \ntail\n.\n\n\nIf\n\n\n\n\ntail can be recognized as a function call or a macro call, and\n\n\nneither bare \n_\n nor \n_...\n is a positional argument to \ntail\n\n\n\n\n_\n will be first be inserted as the first argument to \ntail\n.\n\n\nTo prevent insertion, wrap \ntail\n in a \nbegin\n block.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \n==\n\n      \nvcat\n(\n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n \n)\n \n==\n\n      \nvcat\n(\n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n(\n2\n,\n \n1\n)\n \nvcat\n(\n3\n,\n \n_\n...\n)\n \n)\n \n==\n\n      \nvcat\n(\n3\n,\n \n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nbegin\n \nvcat\n(\n2\n)\n \nend\n \n)\n \n==\n\n      \nvcat\n(\n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain e::Expr\n\n\n\n\n\nSeparate single begin blocks out into lines and recur. Return single non-blocks as is.\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \n1\n\n                  \nvcat\n(\n2\n)\n\n               \nend\n)\n \n==\n\n      \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n\n\n\n@\ntest\n \n(@\nchain\n \n1\n \n+\n \n1\n)\n \n==\n \n2\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lazy_call\n \n \nMethod\n.\n\n\n@lazy_call(e)\n\n\n\n\n\nMostly cosmetic; will break apart a function call into a \nLazyCall\n object. Cannot handle keyword arguments at the moment.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \n+\n(\n1\n,\n \n2\n)\n \n)\n \n==\n\n      \ncollect_call\n(\n+\n,\n \n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n(\n1\n)\n \n)\n \n==\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.nonstandard\n \n \nMethod\n.\n\n\n@nonstandard(fs...) Will create a nonstandard evaluation macro for each of the fs functions.\n\n\nEach function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will copy over the docstrings from the standard version to the nonstandard version. #Examples\n\n\nbinaryfun\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nb\n(\n$\na\n,\n \n$\nc\n))\n\n\nchainback\n(\na\n,\n \nb\n,\n \nc\n)\n \n=\n \n:(\n$\nc\n(\n$\nb\n,\n \n$\na\n))\n\n\n@\nnonstandard\n \nbinaryfun\n \nchainback\n\n\n@\ntest\n \n(@\nbinaryfun\n \n1\n \nvcat\n \n2\n)\n \n==\n \nvcat\n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \n(@\nchainback\n \n2\n \n3\n \nvcat\n)\n \n==\n \nvcat\n(\n3\n,\n \n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push_block\n \n \nMethod\n.\n\n\n@push_block(es...)\n\n\nWill break up any begin blocks in \nes\n, create keyword arguments from assignments, and feed them to \npush\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n           \ncollect_arguments\n(\n1\n)\n\n           \n@\npush_block\n \nbegin\n\n               \n2\n\n               \na\n \n=\n \n3\n \nend\n \nend\n)\n \n==\n\n      \npush\n(\ncollect_arguments\n(\n1\n),\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave e\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. You can also weave in \nonly one\n splatted argument. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \n@\nunweave\n \nvcat\n(\n~\na\n,\n \n~\na\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nb\n...\n)\n \n)\n\n                  \nrun\n(\nmap\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n[\n1\n,\n \n1\n,\n \n3\n,\n \n5\n,\n \n7\n],\n \n[\n2\n,\n \n2\n,\n \n4\n,\n \n6\n,\n \n8\n]\n \n]\n\n\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl", 
            "text": "ChainMap.Arguments  ChainMap.Arguments  ChainMap.LazyCall  Base.run  Base.run  Base.run  Base.run  ChainMap.arguments_block  ChainMap.bitnot  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.collect_arguments  ChainMap.collect_call  ChainMap.lazy_call  ChainMap.nonstandard  ChainMap.push  ChainMap.push_block  ChainMap.unshift  ChainMap.unweave  ChainMap.@arguments_block  ChainMap.@chain  ChainMap.@lazy_call  ChainMap.@nonstandard  ChainMap.@push_block  ChainMap.@unweave   #  ChainMap.Arguments     Type .  type Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend  Will store positional and keyword arguments for later use.  source  #  ChainMap.Arguments     Method .  Arguments(positional::Tuple, keyword::Vector)  Convert  keyword  to a  Dict  before creating Arguments type.  source  #  ChainMap.LazyCall     Type .  type LazyCall{T  : Function}\n    arguments::Arguments\n    function_call::T\nend  Will store positional and keyword arguments for later use.  source  #  Base.run     Method .   run(a::Arguments, f::Function)  Call  f  on the arguments in  a  Examples  test_function ( a ,   b ;   c   =   4 )   =   a   -   b   +   c  @ test   (@ chain   begin \n                   collect_arguments ( 1 ,   2 ,   c   =   3 ) \n                   run ( test_function ) \n               end )   == \n       test_function ( 1 ,   2 ,   c   =   3 )   source  #  Base.run     Method .   run(a::Arguments)  Call  run  on the arguments in  a  Examples  Test . @ test   (@ chain   begin \n                  collect_call ( vcat ,   [ 1 ,   2 ],   [ 3 ,   4 ]) \n                  collect_arguments ( map ) \n                  run \n                  vcat ( _ ... ) \n              end )   == \n       [   1 ,   3 ,   2 ,   4   ]   source  #  Base.run     Method .   run(l::LazyCall, f::Function)  Insert  l.function  as the first positional arguments in  l.arguments , the standard position for functional programming, then call  f  on the result.  Examples  @ test   (@ chain   begin \n                   collect_arguments ([ 1 ,   2 ],   [ 3 , 4 ]) \n                   LazyCall ( vcat ) \n                   run ( map ) \n                   vcat ( _ ... ) \n               end )   == \n       [   1 ,   3 ,   2 ,   4   ]   source  #  Base.run     Method .   run(l::LazyCall)  Call  l.function_call  on the arguments in  l.arguments  Examples  test_function ( a ,   b ;   c   =   4 )   =   a   -   b   +   c  @ test   (@ chain   begin \n                   collect_arguments ( 1 ,   2 ,   c   =   3 ) \n                   LazyCall ( test_function ) \n                   run \n               end )   == \n       test_function ( 1 ,   2 ,   c   =   3 )   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @unweave  Examples  @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.collect_arguments     Method .  collect_arguments(positional...; keyword...)  Easy way to build an  Arguments  type.  Examples  a   =   collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  @ test   a . positional   ==   ( 1 ,   2 )  @ test   a . keyword   ==   Dict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  ChainMap.collect_call     Method .  collect_call ( f : :Function ,   positional ...;   keyword ...)   Easy way to build an  LazyCall  type.  Examples  test_function ( a ,   b )   =   vcat ( a ,   b )  @ test   (@ chain   begin \n                   collect_call ( test_function ,   [ 1 ,   2 ],   [ 3 ,   4 ]) \n                   run ( map ) \n                   vcat ( _ ... ) \n               end )   == \n       [   1 ,   3 ,   2 ,   4   ]   source  #  ChainMap.push     Method .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  arguments_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   3 ) \n     push ( 2 ,   b   =   4 )  end  @ test   arguments_test   == \n       collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )   source  #  ChainMap.unshift     Method .  unshift(arguments::Arguments, positional...)  Add positional arguments to an already existing arguments type. Arguments are added at the start.  Examples  @ test   (@ chain   begin \n                   collect_arguments ( 2 ,   a   =   3 ) \n                   unshift ( 1 ) \n               end )   == \n             collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.@arguments_block     Macro .  @arguments_block(es...)  Will break up any begin blocks in  es  into lines, create keyword arguments from assignments, and feed all arguments to  collect_arguments", 
            "title": "ChainMap.jl"
        }, 
        {
            "location": "/#examples", 
            "text": "@ test   (@ chain   begin \n            1 \n            @ arguments_block   begin \n                2 \n                a   =   3   end   end )   == \n       collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.@chain     Macro .  @chain head tail::Expr  @chain  always substitutes  head  into  _  in  tail .  If   tail can be recognized as a function call or a macro call, and  neither bare  _  nor  _...  is a positional argument to  tail   _  will be first be inserted as the first argument to  tail .  To prevent insertion, wrap  tail  in a  begin  block.  Examples  @ test   (   @ chain   1   vcat ( 2 )   )   == \n       vcat ( 1 ,   2 )  @ test   (   @ chain   1   vcat ( 2 ,   _ )   )   == \n       vcat ( 2 ,   1 )  @ test   (   @ chain   ( 2 ,   1 )   vcat ( 3 ,   _ ... )   )   == \n       vcat ( 3 ,   2 ,   1 )  @ test   (   @ chain   1   begin   vcat ( 2 )   end   )   == \n       vcat ( 2 )   @chain head tail  Call  tail  on  head  Examples  @ test   (@ chain   1   vcat )   ==   vcat ( 1 )   @chain e::Expr  Separate single begin blocks out into lines and recur. Return single non-blocks as is.  Examples  @ test   (@ chain   begin \n                   1 \n                   vcat ( 2 ) \n                end )   == \n       @ chain   1   vcat ( 2 )  @ test   (@ chain   1   +   1 )   ==   2   @chain es...  Reduce  @chain  over  es  Examples  @ test   (   @ chain   1   vcat ( 2 )   vcat ( 3 )   )   == \n       (   @ chain   (   @ chain   1   vcat ( 2 )   )   vcat ( 3 )   )   source  #  ChainMap.@lazy_call     Macro .  @lazy_call(e)  Mostly cosmetic; will break apart a function call into a  LazyCall  object. Cannot handle keyword arguments at the moment.  Examples  @ test   (   @ lazy_call   + ( 1 ,   2 )   )   == \n       collect_call ( + ,   1 ,   2 )  @ test   (   @ lazy_call ( 1 )   )   ==   1   source  #  ChainMap.@nonstandard     Macro .  @nonstandard(fs...) Will create a nonstandard evaluation macro for each of the fs functions.  Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will copy over the docstrings from the standard version to the nonstandard version. #Examples  binaryfun ( a ,   b ,   c )   =   :( $ b ( $ a ,   $ c ))  chainback ( a ,   b ,   c )   =   :( $ c ( $ b ,   $ a ))  @ nonstandard   binaryfun   chainback  @ test   (@ binaryfun   1   vcat   2 )   ==   vcat ( 1 ,   2 )  @ test   (@ chainback   2   3   vcat )   ==   vcat ( 3 ,   2 )   source  #  ChainMap.@push_block     Macro .  @push_block(es...)  Will break up any begin blocks in  es , create keyword arguments from assignments, and feed them to  push", 
            "title": "Examples"
        }, 
        {
            "location": "/#examples_1", 
            "text": "@ test   (@ chain   begin \n            collect_arguments ( 1 ) \n            @ push_block   begin \n                2 \n                a   =   3   end   end )   == \n       push ( collect_arguments ( 1 ),   2 ,   a   =   3 )   source  #  ChainMap.@unweave     Macro .  @unweave e  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. You can also weave in  only one  splatted argument. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot .  Examples  a   =   [ 1 ,   2 ]  b   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  @ test   (@ chain   begin \n                   @ unweave   vcat ( ~ a ,   ~ a ,   ~ [ 3 ,   4 ],   ~ ( b ... )   ) \n                   run ( map ) \n               end )   == \n       [   [ 1 ,   1 ,   3 ,   5 ,   7 ],   [ 2 ,   2 ,   4 ,   6 ,   8 ]   ]   source  #  ChainMap.arguments_block     Method .  @arguments_block(es...)  Will break up any begin blocks in  es  into lines, create keyword arguments from assignments, and feed all arguments to  collect_arguments", 
            "title": "Examples"
        }, 
        {
            "location": "/#examples_2", 
            "text": "@ test   (@ chain   begin \n            1 \n            @ arguments_block   begin \n                2 \n                a   =   3   end   end )   == \n       collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.chain     Method .  @chain es...  Reduce  @chain  over  es  Examples  @ test   (   @ chain   1   vcat ( 2 )   vcat ( 3 )   )   == \n       (   @ chain   (   @ chain   1   vcat ( 2 )   )   vcat ( 3 )   )   source  #  ChainMap.chain     Method .  @chain head tail  Call  tail  on  head  Examples  @ test   (@ chain   1   vcat )   ==   vcat ( 1 )   source  #  ChainMap.chain     Method .  @chain head tail::Expr  @chain  always substitutes  head  into  _  in  tail .  If   tail can be recognized as a function call or a macro call, and  neither bare  _  nor  _...  is a positional argument to  tail   _  will be first be inserted as the first argument to  tail .  To prevent insertion, wrap  tail  in a  begin  block.  Examples  @ test   (   @ chain   1   vcat ( 2 )   )   == \n       vcat ( 1 ,   2 )  @ test   (   @ chain   1   vcat ( 2 ,   _ )   )   == \n       vcat ( 2 ,   1 )  @ test   (   @ chain   ( 2 ,   1 )   vcat ( 3 ,   _ ... )   )   == \n       vcat ( 3 ,   2 ,   1 )  @ test   (   @ chain   1   begin   vcat ( 2 )   end   )   == \n       vcat ( 2 )   source  #  ChainMap.chain     Method .  @chain e::Expr  Separate single begin blocks out into lines and recur. Return single non-blocks as is.  Examples  @ test   (@ chain   begin \n                   1 \n                   vcat ( 2 ) \n                end )   == \n       @ chain   1   vcat ( 2 )  @ test   (@ chain   1   +   1 )   ==   2   source  #  ChainMap.lazy_call     Method .  @lazy_call(e)  Mostly cosmetic; will break apart a function call into a  LazyCall  object. Cannot handle keyword arguments at the moment.  Examples  @ test   (   @ lazy_call   + ( 1 ,   2 )   )   == \n       collect_call ( + ,   1 ,   2 )  @ test   (   @ lazy_call ( 1 )   )   ==   1   source  #  ChainMap.nonstandard     Method .  @nonstandard(fs...) Will create a nonstandard evaluation macro for each of the fs functions.  Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called. Will copy over the docstrings from the standard version to the nonstandard version. #Examples  binaryfun ( a ,   b ,   c )   =   :( $ b ( $ a ,   $ c ))  chainback ( a ,   b ,   c )   =   :( $ c ( $ b ,   $ a ))  @ nonstandard   binaryfun   chainback  @ test   (@ binaryfun   1   vcat   2 )   ==   vcat ( 1 ,   2 )  @ test   (@ chainback   2   3   vcat )   ==   vcat ( 3 ,   2 )   source  #  ChainMap.push_block     Method .  @push_block(es...)  Will break up any begin blocks in  es , create keyword arguments from assignments, and feed them to  push", 
            "title": "Examples"
        }, 
        {
            "location": "/#examples_3", 
            "text": "@ test   (@ chain   begin \n            collect_arguments ( 1 ) \n            @ push_block   begin \n                2 \n                a   =   3   end   end )   == \n       push ( collect_arguments ( 1 ),   2 ,   a   =   3 )   source  #  ChainMap.unweave     Method .  @unweave e  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. You can also weave in  only one  splatted argument. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot .  Examples  a   =   [ 1 ,   2 ]  b   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  @ test   (@ chain   begin \n                   @ unweave   vcat ( ~ a ,   ~ a ,   ~ [ 3 ,   4 ],   ~ ( b ... )   ) \n                   run ( map ) \n               end )   == \n       [   [ 1 ,   1 ,   3 ,   5 ,   7 ],   [ 2 ,   2 ,   4 ,   6 ,   8 ]   ]   source", 
            "title": "Examples"
        }
    ]
}