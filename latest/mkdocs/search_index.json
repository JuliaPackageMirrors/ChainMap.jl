{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl\n\n\n\n\nChainMap.Arguments\n\n\nChainMap.Arguments\n\n\nChainMap.LazyCall\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nBase.run\n\n\nChainMap.bitnot\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.chain\n\n\nChainMap.collect_arguments\n\n\nChainMap.collect_call\n\n\nChainMap.lazy_call\n\n\nChainMap.push\n\n\nChainMap.unshift\n\n\nChainMap.unweave\n\n\nChainMap.@chain\n\n\nChainMap.@lazy_call\n\n\nChainMap.@unweave\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\ntype Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use.\n\n\nsource\n\n\n#\n\n\nChainMap.Arguments\n \n \nMethod\n.\n\n\nArguments(positional::Tuple, keyword::Vector)\n\n\n\n\n\nConvert \nkeyword\n to a \nDict\n before creating Arguments type.\n\n\nsource\n\n\n#\n\n\nChainMap.LazyCall\n \n \nType\n.\n\n\ntype LazyCall{T \n: Function}\n    arguments::Arguments\n    function_call::T\nend\n\n\n\n\n\nWill store positional and keyword arguments for later use.\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments, f::Function)\n\n\n\n\n\nCall \nf\n on the arguments in \na\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n;\n \nc\n \n=\n \n4\n)\n \n=\n \na\n \n-\n \nb\n \n+\n \nc\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n                  \nrun\n(\ntest_function\n)\n\n              \nend\n)\n \n==\n\n      \ntest_function\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(a::Arguments)\n\n\n\n\n\nCall \nrun\n on the arguments in \na\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nbegin\n\n                 \ncollect_call\n(\n+\n,\n \n[\n1\n,\n \n2\n],\n \n[\n3\n,\n \n4\n])\n\n                 \ncollect_arguments\n(\nmap\n)\n\n                 \nrun\n\n             \nend\n)\n \n==\n\n      \n[\n4\n,\n \n6\n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall, f::Function)\n\n\n\n\n\nInsert \nl.function\n as the first positional arguments in \nl.arguments\n, the standard position for functional programming, then call \nf\n on the result.\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n)\n \n=\n \nvcat\n(\na\n,\n \nb\n)\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n([\n1\n,\n \n2\n],\n \n3\n)\n\n                  \nLazyCall\n(\ntest_function\n)\n\n                  \nrun\n(\nbroadcast\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n3\n]\n \n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nMethod\n.\n\n\n run(l::LazyCall)\n\n\n\n\n\nCall \nl.function_call\n on the arguments in \nl.arguments\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n;\n \nc\n \n=\n \n4\n)\n \n=\n \na\n \n-\n \nb\n \n+\n \nc\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n                  \nLazyCall\n(\ntest_function\n)\n\n                  \nrun\n\n              \nend\n)\n \n==\n\n      \ntest_function\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@unweave\n\n\nExamples\n\n\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_arguments\n \n \nMethod\n.\n\n\ncollect_arguments(positional...; keyword...)\n\n\n\n\n\nEasy way to build an \nArguments\n type.\n\n\nExamples\n\n\na\n \n=\n \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n@\ntest\n \na\n.\npositional\n \n==\n \n(\n1\n,\n \n2\n)\n\n\n@\ntest\n \na\n.\nkeyword\n \n==\n \nDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.collect_call\n \n \nMethod\n.\n\n\ncollect_call\n(\nf\n:\n:Function\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nEasy way to build an \nLazyCall\n type.\n\n\nExamples\n\n\ntest_function\n(\na\n,\n \nb\n)\n \n=\n \nvcat\n(\na\n,\n \nb\n)\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_call\n(\ntest_function\n,\n \n[\n1\n,\n \n2\n],\n \n3\n)\n\n                  \nrun\n(\nbroadcast\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n[\n1\n,\n \n3\n],\n \n[\n2\n,\n \n3\n]\n \n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nMethod\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.\n\n\nExamples\n\n\narguments_test\n \n=\n \n@\nchain\n \nbegin\n\n    \ncollect_arguments\n(\n1\n,\n \na\n \n=\n \n3\n)\n\n    \npush\n(\n2\n,\n \nb\n \n=\n \n4\n)\n\n\nend\n\n\n\n@\ntest\n \narguments_test\n \n==\n\n      \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nMethod\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to an already existing arguments type. Arguments are added at the start.\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \ncollect_arguments\n(\n2\n,\n \na\n \n=\n \n3\n)\n\n                  \nunshift\n(\n1\n)\n\n              \nend\n)\n \n==\n\n            \ncollect_arguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\nchain (generic function with 4 methods)\n\n\nsource\n\n\n#\n\n\nChainMap.@lazy_call\n \n \nMacro\n.\n\n\nlazy_call (generic function with 1 method)\n\n\nsource\n\n\n#\n\n\nChainMap.@unweave\n \n \nMacro\n.\n\n\nunweave (generic function with 1 method)\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain es...\n\n\n\n\n\nReduce \n@chain\n over \nes\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \nvcat\n(\n3\n)\n \n)\n \n==\n\n      \n(\n \n@\nchain\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \nvcat\n(\n3\n)\n \n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail\n\n\n\n\n\nCall \ntail\n on \nhead\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \n1\n \nvcat\n)\n \n==\n \nvcat\n(\n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain head tail::Expr\n\n\n\n\n\n@chain\n always substitutes \nhead\n into \n_\n in \ntail\n.\n\n\nIf\n\n\n\n\ntail can be recognized as a function call or a macro call, and\n\n\nneither bare \n_\n nor \n_...\n is a positional argument to \ntail\n\n\n\n\n_\n will be first be inserted as the first argument to \ntail\n.\n\n\nTo prevent insertion, wrap \ntail\n in a \nbegin\n block.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n \n)\n \n==\n\n      \nvcat\n(\n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nvcat\n(\n2\n,\n \n_\n)\n \n)\n \n==\n\n      \nvcat\n(\n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n(\n2\n,\n \n1\n)\n \nvcat\n(\n3\n,\n \n_\n...\n)\n \n)\n \n==\n\n      \nvcat\n(\n3\n,\n \n2\n,\n \n1\n)\n\n\n\n@\ntest\n \n(\n \n@\nchain\n \n1\n \nbegin\n \nvcat\n(\n2\n)\n \nend\n \n)\n \n==\n\n      \nvcat\n(\n2\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.chain\n \n \nMethod\n.\n\n\n@chain e::Expr\n\n\n\n\n\nSeparate single begin blocks out into lines and recur. Return single non-blocks as is.\n\n\nExamples\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \n1\n\n                  \nvcat\n(\n2\n)\n\n               \nend\n)\n \n==\n\n      \n@\nchain\n \n1\n \nvcat\n(\n2\n)\n\n\n\n@\ntest\n \n(@\nchain\n \n1\n \n+\n \n1\n)\n \n==\n \n2\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.lazy_call\n \n \nMethod\n.\n\n\n@lazy_call(e)\n\n\n\n\n\nMostly cosmetic; will break apart a function call into a \nLazyCall\n object. Cannot handle keyword arguments at the moment.\n\n\nExamples\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n \n+\n(\n1\n,\n \n2\n)\n \n)\n \n==\n\n      \ncollect_call\n(\n+\n,\n \n1\n,\n \n2\n)\n\n\n\n@\ntest\n \n(\n \n@\nlazy_call\n(\n1\n)\n \n)\n \n==\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unweave\n \n \nMethod\n.\n\n\n@unweave e\n\n\n\n\n\nInterprets \ne\n as a function with its positional arguments wrapped in tildas and interwoven into it.\n\n\nWill return a \nLazyCall\n object containing both an anonymous function and its arguments. You can also weave in \nonly one\n splatted argument. Make multi-line functions by wrapping in a begin block. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\n\n@\ntest\n \n(@\nchain\n \nbegin\n\n                  \n@\nunweave\n \nvcat\n(\n~\na\n,\n \n~\na\n,\n \n~\n[\n3\n,\n \n4\n],\n \n~\n(\nb\n...\n)\n \n)\n\n                  \nrun\n(\nmap\n)\n\n              \nend\n)\n \n==\n\n      \n[\n \n[\n1\n,\n \n1\n,\n \n3\n,\n \n5\n,\n \n7\n],\n \n[\n2\n,\n \n2\n,\n \n4\n,\n \n6\n,\n \n8\n]\n \n]\n\n\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl", 
            "text": "ChainMap.Arguments  ChainMap.Arguments  ChainMap.LazyCall  Base.run  Base.run  Base.run  Base.run  ChainMap.bitnot  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.chain  ChainMap.collect_arguments  ChainMap.collect_call  ChainMap.lazy_call  ChainMap.push  ChainMap.unshift  ChainMap.unweave  ChainMap.@chain  ChainMap.@lazy_call  ChainMap.@unweave   #  ChainMap.Arguments     Type .  type Arguments\n    positional::Tuple\n    keyword::Dict{Symbol, Any}\nend  Will store positional and keyword arguments for later use.  source  #  ChainMap.Arguments     Method .  Arguments(positional::Tuple, keyword::Vector)  Convert  keyword  to a  Dict  before creating Arguments type.  source  #  ChainMap.LazyCall     Type .  type LazyCall{T  : Function}\n    arguments::Arguments\n    function_call::T\nend  Will store positional and keyword arguments for later use.  source  #  Base.run     Method .   run(a::Arguments, f::Function)  Call  f  on the arguments in  a  Examples  test_function ( a ,   b ;   c   =   4 )   =   a   -   b   +   c  @ test   (@ chain   begin \n                   collect_arguments ( 1 ,   2 ,   c   =   3 ) \n                   run ( test_function ) \n               end )   == \n       test_function ( 1 ,   2 ,   c   =   3 )   source  #  Base.run     Method .   run(a::Arguments)  Call  run  on the arguments in  a  Examples  Test . @ test   (@ chain   begin \n                  collect_call ( + ,   [ 1 ,   2 ],   [ 3 ,   4 ]) \n                  collect_arguments ( map ) \n                  run \n              end )   == \n       [ 4 ,   6 ]   source  #  Base.run     Method .   run(l::LazyCall, f::Function)  Insert  l.function  as the first positional arguments in  l.arguments , the standard position for functional programming, then call  f  on the result.  Examples  test_function ( a ,   b )   =   vcat ( a ,   b )  @ test   (@ chain   begin \n                   collect_arguments ([ 1 ,   2 ],   3 ) \n                   LazyCall ( test_function ) \n                   run ( broadcast ) \n               end )   == \n       [   [ 1 ,   3 ],   [ 2 ,   3 ]   ]   source  #  Base.run     Method .   run(l::LazyCall)  Call  l.function_call  on the arguments in  l.arguments  Examples  test_function ( a ,   b ;   c   =   4 )   =   a   -   b   +   c  @ test   (@ chain   begin \n                   collect_arguments ( 1 ,   2 ,   c   =   3 ) \n                   LazyCall ( test_function ) \n                   run \n               end )   == \n       test_function ( 1 ,   2 ,   c   =   3 )   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @unweave  Examples  @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.collect_arguments     Method .  collect_arguments(positional...; keyword...)  Easy way to build an  Arguments  type.  Examples  a   =   collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  @ test   a . positional   ==   ( 1 ,   2 )  @ test   a . keyword   ==   Dict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  ChainMap.collect_call     Method .  collect_call ( f : :Function ,   positional ...;   keyword ...)   Easy way to build an  LazyCall  type.  Examples  test_function ( a ,   b )   =   vcat ( a ,   b )  @ test   (@ chain   begin \n                   collect_call ( test_function ,   [ 1 ,   2 ],   3 ) \n                   run ( broadcast ) \n               end )   == \n       [   [ 1 ,   3 ],   [ 2 ,   3 ]   ]   source  #  ChainMap.push     Method .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end, and new keyword arguments are added to old keyword arguments, or, if the keys match, overwrite them.  Examples  arguments_test   =   @ chain   begin \n     collect_arguments ( 1 ,   a   =   3 ) \n     push ( 2 ,   b   =   4 )  end  @ test   arguments_test   == \n       collect_arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )   source  #  ChainMap.unshift     Method .  unshift(arguments::Arguments, positional...)  Add positional arguments to an already existing arguments type. Arguments are added at the start.  Examples  @ test   (@ chain   begin \n                   collect_arguments ( 2 ,   a   =   3 ) \n                   unshift ( 1 ) \n               end )   == \n             collect_arguments ( 1 ,   2 ,   a   =   3 )   source  #  ChainMap.@chain     Macro .  chain (generic function with 4 methods)  source  #  ChainMap.@lazy_call     Macro .  lazy_call (generic function with 1 method)  source  #  ChainMap.@unweave     Macro .  unweave (generic function with 1 method)  source  #  ChainMap.chain     Method .  @chain es...  Reduce  @chain  over  es  Examples  @ test   (   @ chain   1   vcat ( 2 )   vcat ( 3 )   )   == \n       (   @ chain   (   @ chain   1   vcat ( 2 )   )   vcat ( 3 )   )   source  #  ChainMap.chain     Method .  @chain head tail  Call  tail  on  head  Examples  @ test   (@ chain   1   vcat )   ==   vcat ( 1 )   source  #  ChainMap.chain     Method .  @chain head tail::Expr  @chain  always substitutes  head  into  _  in  tail .  If   tail can be recognized as a function call or a macro call, and  neither bare  _  nor  _...  is a positional argument to  tail   _  will be first be inserted as the first argument to  tail .  To prevent insertion, wrap  tail  in a  begin  block.  Examples  @ test   (   @ chain   1   vcat ( 2 )   )   == \n       vcat ( 1 ,   2 )  @ test   (   @ chain   1   vcat ( 2 ,   _ )   )   == \n       vcat ( 2 ,   1 )  @ test   (   @ chain   ( 2 ,   1 )   vcat ( 3 ,   _ ... )   )   == \n       vcat ( 3 ,   2 ,   1 )  @ test   (   @ chain   1   begin   vcat ( 2 )   end   )   == \n       vcat ( 2 )   source  #  ChainMap.chain     Method .  @chain e::Expr  Separate single begin blocks out into lines and recur. Return single non-blocks as is.  Examples  @ test   (@ chain   begin \n                   1 \n                   vcat ( 2 ) \n                end )   == \n       @ chain   1   vcat ( 2 )  @ test   (@ chain   1   +   1 )   ==   2   source  #  ChainMap.lazy_call     Method .  @lazy_call(e)  Mostly cosmetic; will break apart a function call into a  LazyCall  object. Cannot handle keyword arguments at the moment.  Examples  @ test   (   @ lazy_call   + ( 1 ,   2 )   )   == \n       collect_call ( + ,   1 ,   2 )  @ test   (   @ lazy_call ( 1 )   )   ==   1   source  #  ChainMap.unweave     Method .  @unweave e  Interprets  e  as a function with its positional arguments wrapped in tildas and interwoven into it.  Will return a  LazyCall  object containing both an anonymous function and its arguments. You can also weave in  only one  splatted argument. Make multi-line functions by wrapping in a begin block. To use  ~  as a function, use the alias  bitnot .  Examples  a   =   [ 1 ,   2 ]  b   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  @ test   (@ chain   begin \n                   @ unweave   vcat ( ~ a ,   ~ a ,   ~ [ 3 ,   4 ],   ~ ( b ... )   ) \n                   run ( map ) \n               end )   == \n       [   [ 1 ,   1 ,   3 ,   5 ,   7 ],   [ 2 ,   2 ,   4 ,   6 ,   8 ]   ]   source", 
            "title": "ChainMap.jl"
        }
    ]
}