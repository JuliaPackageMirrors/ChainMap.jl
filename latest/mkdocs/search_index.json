{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl Documentation\n\n\nThis package attempts to integrate mapping and chaining. The chaining code owes heavily to one-more-minute/Lazy.jl.\n\n\n\n\nRead Me\n\n\n\n\nChaining\n\n\nHere is a short example to illustrate the chaining mechanism.\n\n\nreadme\n \n=\n \n@\nlambda\n \n@\nover\n \n@\nchain\n \nbegin\n\n  \n~\n_\n\n  \n-\n(\n1\n)\n\n  \n^\n(\n2\n,\n \n_\n)\n\n  \nbegin\n\n    \na\n \n=\n \n_\n \n-\n \n1\n\n    \nb\n \n=\n \n_\n \n+\n \n1\n\n    \n(\na\n,\n \nb\n)\n\n  \nend\n\n  \nsum\n\n\nend\n\n\n\nTest\n.\n@\ntest\n \nreadme\n([\n1\n,\n \n2\n])\n \n==\n \n[\n2\n,\n \n4\n]\n\n\n\n\n\n\nThree macros, \n@chain\n, \n@lambda\n, and \n@over\n, are included in this mechanism. See docstrings for more information.\n\n\n\n\nArgument Building\n\n\nThere is another mechanism of argument storage. This is conceptually the inverse of chaining. Here is an example:\n\n\nfunction\n test_function\n(\na\n,\n \nb\n,\n \nc\n;\n \nd\n \n=\n \n4\n)\n\n  \na\n \n-\n \nb\n \n+\n \nc\n \n-\n \nd\n\n\nend\n\n\n\ntest_arguments\n \n=\n \n@\nchain\n \nbegin\n\n  \n1\n\n  \nArguments\n\n  \npush\n(\n2\n,\n \nd\n \n=\n \n2\n)\n\n  \nunshift\n(\n3\n)\n\n  \nrun\n(\ntest_function\n)\n\n\nend\n\n\n\nTest\n.\n@\ntest\n \ntest_arguments\n \n==\n \ntest_function\n(\n3\n,\n \n1\n,\n \n2\n;\n \nd\n \n=\n \n2\n)\n\n\n\n\n\n\nThere are four functions in this mechanism: \nArguments\n, \npush\n, \nunshift\n, and \nrun\n. See docstrings for more information.\n\n\n\n\nMacro generation\n\n\nThere are several macros that create new functions/macros based on existing functions included: \n@nonstandard\n, \n@safe\n, and \n@multiblock\n. See docstrings for more information. Note that these functions were used to generate the package itself. Standard evaluation versions exist for all exported macros.\n\n\n\n\nAliasing\n\n\nIf you want shorter versions of the chaining functions for convenience, run the code below.\n\n\nc\n \n=\n \nChainMap\n.\nchain\n\n\no\n \n=\n \nChainMap\n.\nover\n\n\nl\n \n=\n \nChainMap\n.\nlambda\n\n\n@\nnonstandard\n \nc\n \no\n \nl\n\n\n\n\n\n\nThis will create, for example, the \n@c\n macro as identical to \n@chain\n.\n\n\n\n\nIndex of exports\n\n\n\n\nChainMap.Arguments\n\n\nBase.run\n\n\nChainMap.bitnot\n\n\nChainMap.push\n\n\nChainMap.remove_suffix\n\n\nChainMap.unshift\n\n\nChainMap.@chain\n\n\nChainMap.@lambda\n\n\nChainMap.@multiblock\n\n\nChainMap.@nonstandard\n\n\nChainMap.@over\n\n\nChainMap.@safe\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\nArguments\n\n\n\n\n\nA type that can be used to store arguments. Will store positional and keyword arguments for later use.\n\n\nExamples\n\n\na\n \n=\n \nArguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\nTest\n.\n@\ntest\n \na\n.\npositional\n \n==\n\n           \n(\n1\n,\n \n2\n)\n\n\nTest\n.\n@\ntest\n \na\n.\nkeyword\n \n==\n\n           \nDict\n{\nSymbol\n,\n \nAny\n}(:\na\n \n=\n \n3\n,\n \n:\nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nFunction\n.\n\n\n run(a::Arguments, f)\n\n\n\n\n\nCall \nf\n on the arguments in \na\n\n\nExamples\n\n\ntestfunction\n(\na\n,\n \nb\n;\n \nc\n \n=\n \n4\n)\n \n=\n \na\n \n-\n \nb\n \n+\n \nc\n\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nArguments\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n \nrun\n(\ntestfunction\n)\n \n)\n \n==\n\n           \ntestfunction\n(\n1\n,\n \n2\n,\n \nc\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\n\nAlias for \n~\n for use within \n@over\n.\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \nbitnot\n(\n1\n)\n \n==\n \n~\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nFunction\n.\n\n\npush\n(\narguments\n:\n:Arguments\n,\n \npositional\n...;\n \nkeyword\n...)\n\n\n\n\n\n\nAdd positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end. Note that push can also be used in any other context that push! is defined; it will copy the first argument before executing.\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nArguments\n(\n1\n,\n \na\n \n=\n \n3\n)\n \npush\n(\n2\n,\n \nb\n \n=\n \n4\n)\n \n)\n \n==\n\n           \nArguments\n(\n1\n,\n \n2\n,\n \na\n \n=\n \n3\n,\n \nb\n \n=\n \n4\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.remove_suffix\n \n \nFunction\n.\n\n\nremove_suffix(suffixed::AbstractString, suffix::AbstractString)\n\n\n\n\n\nWill remove a \nsuffix\n from \nsuffixed\n.\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \nremove_suffix\n(\nhi_there\n,\n \n_there\n)\n \n==\n \nhi\n\n\nTest\n.\n@\ntest_throws\n \nErrorException\n \nremove_suffix\n(\nhi\n,\n \nand_bye\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nFunction\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\n\nAdd positional arguments to an already existing arguments type. Arguments are added at the start. Note that unshift can also be used in any other context that unshift! is defined; it will copy the first argument before executing.\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nArguments\n(\n1\n,\n \na\n \n=\n \n3\n)\n \nunshift\n(\n2\n)\n \n)\n \n==\n\n           \nArguments\n(\n2\n,\n \n1\n,\n \na\n \n=\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\n@chain single\n\n\n\n\n\nSeparate single blocks out into lines and recur, return single non-blocks.\n\n\n@chain head tail\n\n\n\n\n\n@chain\n always substitutes \nhead\n into \n_\n in \ntail\n.\n\n\nIn addition, insertion of \nhead\n to the first argument of \ntail\n is default. Insertion is overridden in two ways: if bare \n_\n or \n_...\n is an argument to \ntail\n, or if \ntail\n is a block.\n\n\n@chain head tails...\n\n\n\n\n\nReduce \n@chain\n over \n(head, tails...)\n.\n\n\nExamples\n\n\nplus\n(\na\n,\n \nb\n)\n \n=\n \na\n \n+\n \nb\n\n\nminus\n(\na\n,\n \nb\n)\n \n=\n \na\n \n-\n \nb\n\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nbegin\n\n                     \n1\n\n                     \nplus\n(\n1\n)\n\n                   \nend\n)\n \n==\n\n           \n@\nchain\n \n1\n \nplus\n(\n1\n)\n\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \n1\n \nminus\n(\n2\n,\n \n_\n)\n \n)\n \n==\n\n           \nminus\n(\n2\n,\n \n1\n)\n\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \n1\n \nplus\n(\n2\n)\n \n)\n \n==\n\n           \nplus\n(\n1\n,\n \n2\n)\n\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \nbegin\n\n                     \n1\n\n                     \nbegin\n\n                       \nb\n \n=\n \n2\n\n                       \nminus\n(\nb\n,\n \n_\n)\n\n                     \nend\n\n                   \nend\n)\n \n==\n\n           \nbegin\n\n             \nb\n \n=\n \n2\n\n             \nminus\n(\nb\n,\n \n1\n)\n\n           \nend\n\n\n\nTest\n.\n@\ntest\n \n(@\nchain\n \n1\n \nminus\n(\n2\n)\n \nplus\n(\n3\n)\n \n)\n \n==\n\n           \nplus\n(\nminus\n(\n1\n,\n \n2\n),\n \n3\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@lambda\n \n \nMacro\n.\n\n\n@lambda(e)\n\n\n\n\n\nAn anonymous function is constructed, with \n_\n as an input varible.\n\n\nExamples\n\n\ntestlambda\n \n=\n \n@\nlambda\n \n-\n(\n2\n,\n \n_\n)\n\n\nTest\n.\n@\ntest\n  \ntestlambda\n(\n1\n)\n \n==\n \n-\n(\n2\n,\n \n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@multiblock\n \n \nMacro\n.\n\n\n@multiblock(fs...)\n\n\n\n\n\nIf \nf1\n is a function taking one argument ending in \"1\" which will generate code, \nf\n will be defined. In \nf\n, \nf1\n will be mapped over all arguments and the results will be returned in one code block. This will happen for all \nf1\n functions in \nfs...\n.\n\n\nExamples\n\n\nline_to_block1\n(\nf\n)\n \n=\n \nf\n\n\ndouble_line_to_block1\n(\nf\n)\n \n=\n \n:(\n$\nf\n;\n \n$\nf\n)\n\n\n\n@\nmultiblock\n \nline_to_block1\n \ndouble_line_to_block1\n\n\n@\nnonstandard\n \nline_to_block\n \ndouble_line_to_block\n\n\n\n(@\nline_to_block\n \na\n \n=\n \n2\n \na\n \n-\n \n1\n)\n \n==\n \n1\n\n\n@\ndouble_line_to_block\n \na\n \n=\n \na\n \n+\n \n1\n \na\n \n=\n \na\n/\n2\n\n\nTest\n.\n@\ntest\n \na\n \n==\n \n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\n@nonstandard_single(fs...)\n\n\n\n\n\nThe same as \n@nonstandard\n, except that generated macros will take only one argument.\n\n\nExamples\n\n\nprint_once\n(\nf\n)\n \n=\n \n:(\nstring\n(\nf\n))\n\n\nrepeat_twice\n(\nf\n)\n \n=\n \n:(\nstring\n(\nf\n,\n \n \n,\n \nf\n))\n\n\n\n@\nnonstandard_single\n \nrepeat_once\n \nrepeat_twice\n\n\n\nTest\n.\n@\ntest\n \n(@\nrepeat_once\n \nhi\n)\n \n==\n \nhi\n\n\nTest\n.\n@\ntest\n \n(@\nrepeat_twice\n \nhi\n)\n \n==\n \nhi hi\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@over\n \n \nMacro\n.\n\n\n@over e\n\n\n\n\n\nInterprets e as a function to broadcast with, and expressions wrapped with tildas as objects to broadcast over.\n\n\nYou can also map over splatted arguments, but only one. Make multi-line functions by wrapping in blocks. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\nTest\n.\n@\ntest\n \n(@\nover\n \n+\n(\n \n~\n[\n1\n,\n \n2\n],\n \n~\n[\n3\n,\n \n4\n]\n \n)\n \n)\n \n==\n\n           \n[\n1\n \n+\n \n3\n,\n \n2\n \n+\n \n4\n]\n\n\n\na\n \n=\n \n[\n1\n,\n \n2\n]\n\n\nb\n \n=\n \n[\n3\n,\n \n4\n]\n\n\nc\n \n=\n \n(\n \n[\n5\n,\n \n6\n],\n \n[\n7\n,\n \n8\n]\n \n)\n\n\nd\n \n=\n \n9\n\n\n\nTest\n.\n@\ntest\n \n(@\nover\n \n~\na\n \n+\n \n~\na\n \n+\n \n~\nb\n)\n \n==\n\n           \n[\n1\n \n+\n \n1\n \n+\n \n3\n,\n \n2\n \n+\n \n2\n \n+\n \n4\n]\n\n\n\nTest\n.\n@\ntest\n \n(@\nover\n \n+\n(\n~\na\n,\n \n~\nd\n)\n \n)\n \n==\n\n           \n[\n1\n \n+\n \n9\n,\n \n2\n \n+\n \n9\n]\n\n\n\nTest\n.\n@\ntest\n \n(@\nover\n \n~\na\n \n+\n \n~\n(\nc\n...\n)\n \n)\n \n==\n\n           \n[\n \n[\n1\n \n+\n \n5\n \n+\n \n7\n],\n \n[\n2\n \n+\n \n6\n \n+\n \n8\n]\n \n]\n\n\n\nTest\n.\n@\ntest\n \n(@\nover\n \nbegin\n\n                    \ne\n \n=\n \n~\na\n\n                    \ne\n \n+\n \n1\n\n                  \nend\n \n)\n \n==\n\n            \n[\n2\n,\n \n3\n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@safe\n \n \nMacro\n.\n\n\n@safe(fs...)\n\n\n\n\n\nDefines a new version of mutate-in-place functions like \npush!\n that copies the first positional argument before processing.\n\n\nThe new function will have a name without !, like \npush\n. Can be used on multiple functions.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl-documentation", 
            "text": "This package attempts to integrate mapping and chaining. The chaining code owes heavily to one-more-minute/Lazy.jl.", 
            "title": "ChainMap.jl Documentation"
        }, 
        {
            "location": "/#read-me", 
            "text": "", 
            "title": "Read Me"
        }, 
        {
            "location": "/#chaining", 
            "text": "Here is a short example to illustrate the chaining mechanism.  readme   =   @ lambda   @ over   @ chain   begin \n   ~ _ \n   - ( 1 ) \n   ^ ( 2 ,   _ ) \n   begin \n     a   =   _   -   1 \n     b   =   _   +   1 \n     ( a ,   b ) \n   end \n   sum  end  Test . @ test   readme ([ 1 ,   2 ])   ==   [ 2 ,   4 ]   Three macros,  @chain ,  @lambda , and  @over , are included in this mechanism. See docstrings for more information.", 
            "title": "Chaining"
        }, 
        {
            "location": "/#argument-building", 
            "text": "There is another mechanism of argument storage. This is conceptually the inverse of chaining. Here is an example:  function  test_function ( a ,   b ,   c ;   d   =   4 ) \n   a   -   b   +   c   -   d  end  test_arguments   =   @ chain   begin \n   1 \n   Arguments \n   push ( 2 ,   d   =   2 ) \n   unshift ( 3 ) \n   run ( test_function )  end  Test . @ test   test_arguments   ==   test_function ( 3 ,   1 ,   2 ;   d   =   2 )   There are four functions in this mechanism:  Arguments ,  push ,  unshift , and  run . See docstrings for more information.", 
            "title": "Argument Building"
        }, 
        {
            "location": "/#macro-generation", 
            "text": "There are several macros that create new functions/macros based on existing functions included:  @nonstandard ,  @safe , and  @multiblock . See docstrings for more information. Note that these functions were used to generate the package itself. Standard evaluation versions exist for all exported macros.", 
            "title": "Macro generation"
        }, 
        {
            "location": "/#aliasing", 
            "text": "If you want shorter versions of the chaining functions for convenience, run the code below.  c   =   ChainMap . chain  o   =   ChainMap . over  l   =   ChainMap . lambda  @ nonstandard   c   o   l   This will create, for example, the  @c  macro as identical to  @chain .", 
            "title": "Aliasing"
        }, 
        {
            "location": "/#index-of-exports", 
            "text": "ChainMap.Arguments  Base.run  ChainMap.bitnot  ChainMap.push  ChainMap.remove_suffix  ChainMap.unshift  ChainMap.@chain  ChainMap.@lambda  ChainMap.@multiblock  ChainMap.@nonstandard  ChainMap.@over  ChainMap.@safe   #  ChainMap.Arguments     Type .  Arguments  A type that can be used to store arguments. Will store positional and keyword arguments for later use.  Examples  a   =   Arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )  Test . @ test   a . positional   == \n            ( 1 ,   2 )  Test . @ test   a . keyword   == \n            Dict { Symbol ,   Any }(: a   =   3 ,   : b   =   4 )   source  #  Base.run     Function .   run(a::Arguments, f)  Call  f  on the arguments in  a  Examples  testfunction ( a ,   b ;   c   =   4 )   =   a   -   b   +   c  Test . @ test   (@ chain   Arguments ( 1 ,   2 ,   c   =   3 )   run ( testfunction )   )   == \n            testfunction ( 1 ,   2 ,   c   =   3 )   source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @over .  Examples  Test . @ test   bitnot ( 1 )   ==   ~ 1   source  #  ChainMap.push     Function .  push ( arguments : :Arguments ,   positional ...;   keyword ...)   Add positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end. Note that push can also be used in any other context that push! is defined; it will copy the first argument before executing.  Examples  Test . @ test   (@ chain   Arguments ( 1 ,   a   =   3 )   push ( 2 ,   b   =   4 )   )   == \n            Arguments ( 1 ,   2 ,   a   =   3 ,   b   =   4 )   source  #  ChainMap.remove_suffix     Function .  remove_suffix(suffixed::AbstractString, suffix::AbstractString)  Will remove a  suffix  from  suffixed .", 
            "title": "Index of exports"
        }, 
        {
            "location": "/#examples", 
            "text": "Test . @ test   remove_suffix ( hi_there ,   _there )   ==   hi  Test . @ test_throws   ErrorException   remove_suffix ( hi ,   and_bye )   source  #  ChainMap.unshift     Function .  unshift(arguments::Arguments, positional...)  Add positional arguments to an already existing arguments type. Arguments are added at the start. Note that unshift can also be used in any other context that unshift! is defined; it will copy the first argument before executing.  Examples  Test . @ test   (@ chain   Arguments ( 1 ,   a   =   3 )   unshift ( 2 )   )   == \n            Arguments ( 2 ,   1 ,   a   =   3 )   source  #  ChainMap.@chain     Macro .  @chain single  Separate single blocks out into lines and recur, return single non-blocks.  @chain head tail  @chain  always substitutes  head  into  _  in  tail .  In addition, insertion of  head  to the first argument of  tail  is default. Insertion is overridden in two ways: if bare  _  or  _...  is an argument to  tail , or if  tail  is a block.  @chain head tails...  Reduce  @chain  over  (head, tails...) .  Examples  plus ( a ,   b )   =   a   +   b  minus ( a ,   b )   =   a   -   b  Test . @ test   (@ chain   begin \n                      1 \n                      plus ( 1 ) \n                    end )   == \n            @ chain   1   plus ( 1 )  Test . @ test   (@ chain   1   minus ( 2 ,   _ )   )   == \n            minus ( 2 ,   1 )  Test . @ test   (@ chain   1   plus ( 2 )   )   == \n            plus ( 1 ,   2 )  Test . @ test   (@ chain   begin \n                      1 \n                      begin \n                        b   =   2 \n                        minus ( b ,   _ ) \n                      end \n                    end )   == \n            begin \n              b   =   2 \n              minus ( b ,   1 ) \n            end  Test . @ test   (@ chain   1   minus ( 2 )   plus ( 3 )   )   == \n            plus ( minus ( 1 ,   2 ),   3 )   source  #  ChainMap.@lambda     Macro .  @lambda(e)  An anonymous function is constructed, with  _  as an input varible.  Examples  testlambda   =   @ lambda   - ( 2 ,   _ )  Test . @ test    testlambda ( 1 )   ==   - ( 2 ,   1 )   source  #  ChainMap.@multiblock     Macro .  @multiblock(fs...)  If  f1  is a function taking one argument ending in \"1\" which will generate code,  f  will be defined. In  f ,  f1  will be mapped over all arguments and the results will be returned in one code block. This will happen for all  f1  functions in  fs... .  Examples  line_to_block1 ( f )   =   f  double_line_to_block1 ( f )   =   :( $ f ;   $ f )  @ multiblock   line_to_block1   double_line_to_block1  @ nonstandard   line_to_block   double_line_to_block  (@ line_to_block   a   =   2   a   -   1 )   ==   1  @ double_line_to_block   a   =   a   +   1   a   =   a / 2  Test . @ test   a   ==   1   source  #  ChainMap.@nonstandard     Macro .  @nonstandard_single(fs...)  The same as  @nonstandard , except that generated macros will take only one argument.", 
            "title": "Examples"
        }, 
        {
            "location": "/#examples_1", 
            "text": "print_once ( f )   =   :( string ( f ))  repeat_twice ( f )   =   :( string ( f ,     ,   f ))  @ nonstandard_single   repeat_once   repeat_twice  Test . @ test   (@ repeat_once   hi )   ==   hi  Test . @ test   (@ repeat_twice   hi )   ==   hi hi   source  #  ChainMap.@over     Macro .  @over e  Interprets e as a function to broadcast with, and expressions wrapped with tildas as objects to broadcast over.  You can also map over splatted arguments, but only one. Make multi-line functions by wrapping in blocks. To use  ~  as a function, use the alias  bitnot .  Examples  Test . @ test   (@ over   + (   ~ [ 1 ,   2 ],   ~ [ 3 ,   4 ]   )   )   == \n            [ 1   +   3 ,   2   +   4 ]  a   =   [ 1 ,   2 ]  b   =   [ 3 ,   4 ]  c   =   (   [ 5 ,   6 ],   [ 7 ,   8 ]   )  d   =   9  Test . @ test   (@ over   ~ a   +   ~ a   +   ~ b )   == \n            [ 1   +   1   +   3 ,   2   +   2   +   4 ]  Test . @ test   (@ over   + ( ~ a ,   ~ d )   )   == \n            [ 1   +   9 ,   2   +   9 ]  Test . @ test   (@ over   ~ a   +   ~ ( c ... )   )   == \n            [   [ 1   +   5   +   7 ],   [ 2   +   6   +   8 ]   ]  Test . @ test   (@ over   begin \n                     e   =   ~ a \n                     e   +   1 \n                   end   )   == \n             [ 2 ,   3 ]   source  #  ChainMap.@safe     Macro .  @safe(fs...)  Defines a new version of mutate-in-place functions like  push!  that copies the first positional argument before processing.  The new function will have a name without !, like  push . Can be used on multiple functions.  source", 
            "title": "Examples"
        }
    ]
}