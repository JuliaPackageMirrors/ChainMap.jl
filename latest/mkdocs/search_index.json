{
    "docs": [
        {
            "location": "/", 
            "text": "ChainMap.jl Documentation\n\n\n\n\nChainMap.Arguments\n\n\nBase.run\n\n\nChainMap.bitnot\n\n\nChainMap.push\n\n\nChainMap.unshift\n\n\nChainMap.@chain\n\n\nChainMap.@lambda\n\n\nChainMap.@multiblock\n\n\nChainMap.@nonstandard\n\n\nChainMap.@over\n\n\nChainMap.@safe\n\n\n\n\n#\n\n\nChainMap.Arguments\n \n \nType\n.\n\n\nArguments\n\n\n\n\nA type that can be used to store arguments. Will store positional and keyword arguments for later use.\n\n\nExamples\n\n\na = Arguments(1, 2, a = 3, b = 4)\nTest.@test a.positional ==\n           (1, 2)\nTest.@test a.keyword ==\n           Dict{Symbol, Any}(:a =\n 3, :b =\n 4)\n\n\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nFunction\n.\n\n\n run(a::Arguments, f)\n\n\n\n\nCall \nf\n on the arguments in \na\n\n\nExamples\n\n\ntestfunction(a, b; c = 4) = a - b + c\n\nTest.@test (@chain Arguments(1, 2, c = 3) run(testfunction) ) ==\n           testfunction(1, 2, c = 3)\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.bitnot\n \n \nFunction\n.\n\n\nbitnot\n\n\n\n\nAlias for \n~\n for use within \n@over\n\n\nsource\n\n\n#\n\n\nChainMap.push\n \n \nFunction\n.\n\n\npush(arguments::Arguments, positional...; keyword...)\n\n\n\n\nAdd positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end. Note that push can also be used in any other context that push! is defined; it will copy the first argument before executing.\n\n\nExamples\n\n\nTest.@test (@chain Arguments(1, a = 3) push(2, b = 4) ) ==\n           Arguments(1, 2, a = 3, b = 4)\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.unshift\n \n \nFunction\n.\n\n\nunshift(arguments::Arguments, positional...)\n\n\n\n\nAdd positional arguments to an already existing arguments type. Arguments are added at the start. Note that unshift can also be used in any other context that unshift! is defined; it will copy the first argument before executing.\n\n\nExamples\n\n\nTest.@test (@chain Arguments(1, a = 3) unshift(2) ) ==\n           Arguments(2, 1, a = 3)\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@chain\n \n \nMacro\n.\n\n\n@chain single\n\n\n\n\nSeparate single blocks out into lines and recur, return single non-blocks.\n\n\n@chain head tail\n\n\n\n\n@chain\n always substitutes \nhead\n into \n_\n in \ntail\n.\n\n\nIn addition, insertion of \nhead\n to the first argument of \ntail\n is default. Insertion is overridden in two ways: if bare \n_\n or \n_...\n is an argument to \ntail\n, or if \ntail\n is a block.\n\n\n@chain head tails...\n\n\n\n\nReduce \n@chain\n over \n(head, tails...)\n.\n\n\nExamples\n\n\nplus(a, b) = a + b\nminus(a, b) = a - b\n\nTest.@test (@chain begin\n                     1\n                     plus(1)\n                   end) ==\n           @chain 1 plus(1)\n\nTest.@test (@chain 1 minus(2, _) ) ==\n           minus(2, 1)\n\nTest.@test (@chain 1 plus(2) ) ==\n           plus(1, 2)\n\nTest.@test (@chain begin\n                     1\n                     begin\n                       b = 2\n                       minus(b, _)\n                     end\n                   end) ==\n           begin\n             b = 2\n             minus(b, 1)\n           end\n\nTest.@test (@chain 1 minus(2) plus(3) ) ==\n           plus(minus(1, 2), 3)\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@lambda\n \n \nMacro\n.\n\n\n@lambda(e)\n\n\n\n\nAn anonymous function is constructed, with \n_\n as an input varible.\n\n\nExamples\n\n\ntestlambda = @lambda -(2, _)\nTest.@test  testlambda(1) == -(2, 1)\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@multiblock\n \n \nMacro\n.\n\n\n@multiblock(fs...)\n\n\n\n\nIf \nf1\n is a function taking one argument ending in \"1\" which will generate code, \nf\n will be defined. In \nf\n, \nf1\n will be mapped over all arguments and the results will be returned in one code block. This will happen for all \nf1\n functions in \nfs...\n.\n\n\nsource\n\n\n#\n\n\nChainMap.@nonstandard\n \n \nMacro\n.\n\n\n@nonstandard(fs...)\n\n\n\n\nWill create a nonstandard evaluation macro for each of the fs functions. Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called.\n\n\nsource\n\n\n#\n\n\nChainMap.@over\n \n \nMacro\n.\n\n\n@over e\n\n\n\n\nInterprets e as a function to broadcast with, and expressions wrapped with tildas as objects to broadcast over.\n\n\nYou can also map over splatted arguments, but only one. Make multi-line functions by wrapping in blocks. To use \n~\n as a function, use the alias \nbitnot\n.\n\n\nExamples\n\n\nTest.@test (@over +( ~[1, 2], ~[3, 4] ) ) ==\n           [1 + 3, 2 + 4]\n\na = [1, 2]\nb = [3, 4]\nc = ( [5, 6], [7, 8] )\nd = 9\n\nTest.@test (@over ~a + ~a + ~b) ==\n           [1 + 1 + 3, 2 + 2 + 4]\n\nTest.@test (@over +(~a, ~d) ) ==\n           [1 + 9, 2 + 9]\n\nTest.@test (@over ~a + ~(c...) ) ==\n           [ [1 + 5 + 7], [2 + 6 + 8] ]\n\nTest.@test (@over begin\n                    e = ~a\n                    e + 1\n                  end ) ==\n            [2, 3]\n\n\n\n\nsource\n\n\n#\n\n\nChainMap.@safe\n \n \nMacro\n.\n\n\n@safe(fs...)\n\n\n\n\nDefines a new version of mutate-in-place functions like \npush!\n that copies the first positional argument before processing.\n\n\nThe new function will have a name without !, like \npush\n. Can be used on multiple functions.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#chainmapjl-documentation", 
            "text": "ChainMap.Arguments  Base.run  ChainMap.bitnot  ChainMap.push  ChainMap.unshift  ChainMap.@chain  ChainMap.@lambda  ChainMap.@multiblock  ChainMap.@nonstandard  ChainMap.@over  ChainMap.@safe   #  ChainMap.Arguments     Type .  Arguments  A type that can be used to store arguments. Will store positional and keyword arguments for later use.  Examples  a = Arguments(1, 2, a = 3, b = 4)\nTest.@test a.positional ==\n           (1, 2)\nTest.@test a.keyword ==\n           Dict{Symbol, Any}(:a =  3, :b =  4)  source  #  Base.run     Function .   run(a::Arguments, f)  Call  f  on the arguments in  a  Examples  testfunction(a, b; c = 4) = a - b + c\n\nTest.@test (@chain Arguments(1, 2, c = 3) run(testfunction) ) ==\n           testfunction(1, 2, c = 3)  source  #  ChainMap.bitnot     Function .  bitnot  Alias for  ~  for use within  @over  source  #  ChainMap.push     Function .  push(arguments::Arguments, positional...; keyword...)  Add positional and keyword arguments to an already existing arguments type. Positional arguments are added at the end. Note that push can also be used in any other context that push! is defined; it will copy the first argument before executing.  Examples  Test.@test (@chain Arguments(1, a = 3) push(2, b = 4) ) ==\n           Arguments(1, 2, a = 3, b = 4)  source  #  ChainMap.unshift     Function .  unshift(arguments::Arguments, positional...)  Add positional arguments to an already existing arguments type. Arguments are added at the start. Note that unshift can also be used in any other context that unshift! is defined; it will copy the first argument before executing.  Examples  Test.@test (@chain Arguments(1, a = 3) unshift(2) ) ==\n           Arguments(2, 1, a = 3)  source  #  ChainMap.@chain     Macro .  @chain single  Separate single blocks out into lines and recur, return single non-blocks.  @chain head tail  @chain  always substitutes  head  into  _  in  tail .  In addition, insertion of  head  to the first argument of  tail  is default. Insertion is overridden in two ways: if bare  _  or  _...  is an argument to  tail , or if  tail  is a block.  @chain head tails...  Reduce  @chain  over  (head, tails...) .  Examples  plus(a, b) = a + b\nminus(a, b) = a - b\n\nTest.@test (@chain begin\n                     1\n                     plus(1)\n                   end) ==\n           @chain 1 plus(1)\n\nTest.@test (@chain 1 minus(2, _) ) ==\n           minus(2, 1)\n\nTest.@test (@chain 1 plus(2) ) ==\n           plus(1, 2)\n\nTest.@test (@chain begin\n                     1\n                     begin\n                       b = 2\n                       minus(b, _)\n                     end\n                   end) ==\n           begin\n             b = 2\n             minus(b, 1)\n           end\n\nTest.@test (@chain 1 minus(2) plus(3) ) ==\n           plus(minus(1, 2), 3)  source  #  ChainMap.@lambda     Macro .  @lambda(e)  An anonymous function is constructed, with  _  as an input varible.  Examples  testlambda = @lambda -(2, _)\nTest.@test  testlambda(1) == -(2, 1)  source  #  ChainMap.@multiblock     Macro .  @multiblock(fs...)  If  f1  is a function taking one argument ending in \"1\" which will generate code,  f  will be defined. In  f ,  f1  will be mapped over all arguments and the results will be returned in one code block. This will happen for all  f1  functions in  fs... .  source  #  ChainMap.@nonstandard     Macro .  @nonstandard(fs...)  Will create a nonstandard evaluation macro for each of the fs functions. Each function should be a function that takes and returns expressions. The nonstandard macro will have the same name but will take in code, not expressions, and will evaluate the result locally when the macro is called.  source  #  ChainMap.@over     Macro .  @over e  Interprets e as a function to broadcast with, and expressions wrapped with tildas as objects to broadcast over.  You can also map over splatted arguments, but only one. Make multi-line functions by wrapping in blocks. To use  ~  as a function, use the alias  bitnot .  Examples  Test.@test (@over +( ~[1, 2], ~[3, 4] ) ) ==\n           [1 + 3, 2 + 4]\n\na = [1, 2]\nb = [3, 4]\nc = ( [5, 6], [7, 8] )\nd = 9\n\nTest.@test (@over ~a + ~a + ~b) ==\n           [1 + 1 + 3, 2 + 2 + 4]\n\nTest.@test (@over +(~a, ~d) ) ==\n           [1 + 9, 2 + 9]\n\nTest.@test (@over ~a + ~(c...) ) ==\n           [ [1 + 5 + 7], [2 + 6 + 8] ]\n\nTest.@test (@over begin\n                    e = ~a\n                    e + 1\n                  end ) ==\n            [2, 3]  source  #  ChainMap.@safe     Macro .  @safe(fs...)  Defines a new version of mutate-in-place functions like  push!  that copies the first positional argument before processing.  The new function will have a name without !, like  push . Can be used on multiple functions.  source", 
            "title": "ChainMap.jl Documentation"
        }
    ]
}